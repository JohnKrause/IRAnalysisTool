<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Thermal Image Analysis</title>
<link rel="stylesheet" href="styles.css">
<style>
	* {
		margin: 0;
		padding: 0;
		box-sizing: border-box;
		}
	body, html {
		font-family: Arial, sans-serif;
		background-color: #555;
		height: 100%;
	}
	.page-container {
		width: 100%;
		height: 100%;
		display: flex;
		flex-direction: column;
		flex-wrap: nowrap;
	}
	.title-container {
		width: 100%;
		height: 40px;
		flex: none;
		background-color: rgba(0,0,0,0);
	}
	.title-container h1 {
		margin: 5px;
		text-align: left;
	}
	.app-container {
		width: 100%;
		max-height: calc(100vh - 40px);
		flex: 1 1 auto;
		display: flex;
		flex-direction: row;
	}
	.rightbar-container {
		width: 20%;
		height: 100%;
		flex: 0 0 auto;
		background-color: rgba(25,200,255,0.1);
		display: flex;
		flex-direction: column;
	}
	.loadedfiles-container {
		width: 100%;
		height:50%;
		flex: 0 0 auto;
		display: flex;
		flex-direction: column;
		flex-wrap: nowrap;
		overflow-y: scroll;
	}
	.fileinstance-container {
		width: 100%;
		height:20%;
		flex: 0 0 auto;
		background-color: rgba(25,150,200,0.1);
		display: flex;
		flex-direction: row;
	}
	.fileinstance-image {
		height:100%;
		flex: 0 0 auto;
		object-fit: contain;
		object-position: center;
		padding: 2px;
		background-color: rgba(25,130,85,0.5);
		transition: filter 0.1s;
	}
	.fileinstance-image:hover {
		filter: brightness(70%);
	}
	.fileinstance-controls {
		height:100%;
		flex: 1 0 auto;
		display: flex;
		flex-direction: row;
		flex-wrap: wrap;
	}
	.fileinstance-name {
		width: 100%;
		min-width: 100%;
		height:auto;
		padding: 2px;
		background-color: rgba(25,75,200,0.5);
		flex: 1 0 auto;
	}
	.fileinstance-button {
		width: 10%;
		height:auto;
		flex: auto;
		padding: 2px;
		background-color: rgba(25,50,150,0.5);
	}
	.appgraphics-container{
		width: 80%;
		flex: 1 1 auto;
		display: flex;
		flex-direction: column;
	}
	.thermalcanvas-container{
		width: 100%;
		flex: 1 1 auto;
		display: flex;
		justify-content: center;
  	align-items: center;
	}
	.thermalcanvas-size-container{
		width: auto;
		height: auto;
		position: relative;
	}
	.thermalcanvas-element {
		position: absolute;
		top:0;
		left:0;
	}
	.thermalcanvas-element:hover {
		cursor: crosshair;
	}
	.toolCanvas {
		z-index:2;
	}
	.thermalCanvas {
		z-index:1;
	}
	.analysis-container {
		height: 20%;
		width: 100%;
		flex: 0 0 auto;
		display: flex;
		flex-direction: row;
		background-color: rgba(25,50,150,0.5);
	}
	.analysisinfo-container {
		padding: 10px;
		width: 25%;
		height: 100%;
	}
	.analysiscanvas-container {
		padding: 10px;
		width: 75%;
		height: 100%;
	}
	.analysisCanvas {
		top:0;
		left:0;
		width: 100%;
		height: 100%;
		border: none;
	}
	.hover-red:hover {
		background-color: rgba(95,25,35,0.5);
	}
	.hover-green:hover {
		background-color: rgba(95,150,35,0.5);
	}
</style>

<script>

class EventEmitter {
	constructor() {
		this.events = {};
	}

	addEventListener(event, listener) {
		if (!this.events[event]) {
			this.events[event] = [];
		}
		if (!this.events[event].includes(listener)) {
				this.events[event].push(listener);
		}
	}

	removeEventListener(event, listener) {
		if (this.events[event]) {
			const index = this.events[event].indexOf(listener);
			if (index !== -1) {
					this.events[event].splice(index, 1);
			}
		}
	}

	emit(type, event) {
		if (this.events[type]) {
			this.events[type].forEach(listener => {
				listener.call(this, event);
			});
		}
	}
}

class FileInstanceController extends EventEmitter{
	constructor(thermalArrayModel, fileListId) {
		super();
		this.thermalArrayModel=thermalArrayModel;
		this.activeToolModel= new PointerTool();
		this.fileList = document.getElementById(fileListId);
		this.instanceDiv = null;
	  this.instanceImage = null;
	  this.instanceName = null;
	  this.btnRename = null;
	  this.btnDelete = null;
		this.renderElements();
	}
	renderElements() {
	  const template = document.getElementById("id_fileInstanceTemplate");
	  const fileInstanceElement = template.content.cloneNode(true).firstElementChild;
	  this.fileList.appendChild(fileInstanceElement)
	  this.instanceDiv = fileInstanceElement;
	  this.instanceImage = fileInstanceElement.querySelector("#id_instanceImage");
	  this.instanceImage.addEventListener('click', this.select.bind(this));
	  this.instanceImage.src = this.thermalArrayModel.getThermalPreview();
	  this.instanceName = fileInstanceElement.querySelector("#id_instanceName");
	  this.instanceName.value = this.thermalArrayModel.name;
	  this.instanceName.addEventListener('change', this.rename.bind(this));
	  this.btnRename = fileInstanceElement.querySelector("#id_instanceRename");
	  this.btnRename.addEventListener('click', this.rename.bind(this));
	  this.btnDelete = fileInstanceElement.querySelector("#id_instanceDelete");
	  this.btnDelete.addEventListener('click', this.delete.bind(this));
	}
	rename() {
		this.thermalArrayModel.name=this.instanceName.value;
	}
	delete() {
		this.fileList.removeChild(this.instanceDiv);
		this.emit("delete",{instance:this});
	}
	select() {
		this.emit("select",{instance:this});
	}
}

class IrAnalysisController extends EventEmitter{
	constructor(containerDivId, canvasDivId) {
		super();
		this.containerDiv = document.getElementById(containerDivId);
		this.canvasDiv = document.getElementById(canvasDivId);

		this.fileInstances={};

		this.activeThermalArrayModel = null;
		this.activeThermalImageView = null;
		this.activeToolModel = null;
		this.activeToolView = null;
		this.activeAnalysisView = null;
		this.activeColorPaletteModel = null;

		window.addEventListener('resize',this.resizeWindow.bind(this));
		this.canvasDiv.addEventListener('wheel',this.mouseWheel.bind(this));
		this.canvasDiv.addEventListener('mouseup',this.mouseUp.bind(this));
		this.canvasDiv.addEventListener('mousedown',this.mouseDown.bind(this));
		this.canvasDiv.addEventListener('mousein',this.mouseIn.bind(this));
		this.canvasDiv.addEventListener('mouseout',this.mouseOut.bind(this));
		this.canvasDiv.addEventListener('mousemove',this.mouseMove.bind(this));
		this.canvasDiv.addEventListener('keydown',this.keyboard.bind(this));
	}

	addFileInstance(fileInstanceController) {
		let fileId=0;
		while (this.fileInstances[fileId] !== undefined) {
			fileId++;
		};
		this.fileInstances[fileId]=fileInstanceController;
		this.fileInstances[fileId].addEventListener('select',
				this.selectFileInstance.bind(this));
	}

	setActiveThermalImageView(thermalImageView) {
		if(this.activeThermalImageView) {
			this.activeThermalImageView.removeEventListener('draw',
					this.drawThermalImage.bind(this));
		}
		this.activeThermalImageView=thermalImageView;
		this.activeThermalImageView.addEventListener('draw',
				this.drawThermalImage.bind(this));
		this.synchronizeEverything();
	}

	setActiveToolView(toolView) {
		if(this.activeToolView) {
			this.activeToolView.removeEventListener('draw',
					this.drawTool.bind(this));
		}
		this.activeToolView=toolView;
		this.activeToolView.addEventListener('draw',
				this.drawTool.bind(this));
		this.synchronizeEverything();
	}

	setActiveAnalysisView(analysisView) {
		if(this.activeAnalysisView) {
			this.activeAnalysisView.hide();
			this.activeToolView.removeEventListener('draw',
					this.drawAnalysis.bind(this));
		}
		this.activeAnalysisView=analysisView;
		this.activeAnalysisView.display();
		this.activeAnalysisView.addEventListener('draw',
				this.drawAnalysis.bind(this));
		this.synchronizeEverything();
	}

	setActiveToolModel(toolModel) {
		if(this.activeToolModel) {
			this.activeToolModel.removeEventListener('draw',
					this.drawTool.bind(this));
		}
		this.activeToolModel=toolModel;
		this.activeToolModel.addEventListener('draw',
				this.drawTool.bind(this));
		this.synchronizeEverything();
	}

	setActiveThermalArrayModel(thermalArrayModel) {
		if(this.activeThermalArrayModel) {
			this.activeThermalArrayModel.removeEventListener('arraychange',
					this.arrayChange.bind(this));
		}
		this.activeThermalArrayModel = thermalArrayModel;
		this.activeThermalArrayModel.addEventListener('arraychange',
				this.arrayChange.bind(this));
		this.synchronizeEverything();
	}

	setActiveColorPaletteModel(colorPaletteModel) {
		if(this.activeColorPaletteModel) {
			this.activeColorPaletteModel.removeEventListener('palettechange',
					this.paletteChange.bind(this));
		}
		this.activeColorPaletteModel = colorPaletteModel;
		this.activeColorPaletteModel.addEventListener('palettechange',
				this.paletteChange.bind(this));
		this.synchronizeEverything();
	}

	synchronizeEverything() {
		//Make sure tool has the correct thermal array
		if(this.activeThermalArrayModel && this.activeToolModel) {
			const thermalArray = this.activeThermalArrayModel.getThermalArray();
			this.activeToolModel.setArray(thermalArray);
		}
		//Make sure thermal array has correct color palette
		if(this.activeColorPaletteModel) {
			if(this.activeThermalArrayModel) {
				this.activeThermalArrayModel.setActiveColorPaletteModel(
						this.activeColorPaletteModel);
			}
			if(this.activeToolModel) {
				this.activeToolModel.setActiveColorPaletteModel(
						this.activeColorPaletteModel);
			}

		}
		//Make sure the canvases are the correct size
		this.resizeWindow({});
	}

	selectFileInstance(event) {
		this.setActiveThermalArrayModel(event.instance.thermalArrayModel);
		this.setActiveToolModel(event.instance.activeToolModel);
	}

	drawThermalImage(event) {
		if(this.activeThermalArrayModel) {
			let thermalImageGraphics = this.activeThermalArrayModel.getThermalImage();
			thermalImageGraphics = calcGraphicPixelScale(thermalImageGraphics, 
					this.activeThermalArrayModel.arrayWidth(),
					this.activeThermalArrayModel.arrayHeight(),
					this.activeThermalImageView.canvasWidth(),
					this.activeThermalImageView.canvasHeight());
			this.activeThermalImageView.draw(thermalImageGraphics);
		}
	}

	drawTool(event) {
		if(this.activeToolModel) {
			let toolImageGraphics = this.activeToolModel.getToolGraphics();
			toolImageGraphics = calcGraphicPixelScale(toolImageGraphics, 
					this.activeThermalArrayModel.arrayWidth(),
					this.activeThermalArrayModel.arrayHeight(),
					this.activeThermalImageView.canvasWidth(),
					this.activeThermalImageView.canvasHeight());
			this.activeToolView.draw(toolImageGraphics);

			let analyticsImageGraphics = this.activeToolModel.getAnalyticsGraphics();
			this.activeAnalysisView.draw(analyticsImageGraphics);
		}
	}

	drawAnalysis(event) {
		if(this.activeToolModel) {
			let analyticsImageGraphics = this.activeToolModel.getAnalyticsGraphics();
			this.activeAnalysisView.draw(analyticsImageGraphics);
		}
	}

	arrayChange(event) {
		if(this.activeToolModel) {
			this.activeToolModel.thermalArrayChange();
		}
	}

	paletteChange(event) {
		if(this.activeThermalArrayModel) {
			this.activeThermalArrayModel.paletteChange();
		}
	}

	resizeWindow(event) {
		if(this.activeThermalArrayModel) {
			const arrayHeight = this.activeThermalArrayModel.arrayHeight();
			const arrayWidth = this.activeThermalArrayModel.arrayWidth();
			const divHeight = this.containerDiv.offsetHeight-10;
			const divWidth = this.containerDiv.offsetWidth-10;

			const canvasSize = calcCanvasSize(arrayWidth, arrayHeight, divWidth, divHeight);
			this.canvasDiv.style.width = (canvasSize.width)+'px';
			this.canvasDiv.style.height = (canvasSize.height)+'px';
			if(this.activeThermalImageView) {
				this.activeThermalImageView.setSize(canvasSize.width, canvasSize.height);
			}
			if(this.activeToolView) {
				this.activeToolView.setSize(canvasSize.width, canvasSize.height);
			}
			if(this.activeAnalysisView) {
				this.activeAnalysisView.resizeUpdate();
			}
		}
	}

	mouseWheel(event) {
		if(this.activeToolModel) {
			this.activeToolModel.mouseWheel(event.deltaX, event.deltaY);
		}
	}
	mouseUp(event) {
		if(this.activeToolModel) {
			this.activeToolModel.mouseUp();
		}
	}
	mouseDown(event) {
		if(this.activeToolModel && this.activeThermalArrayModel) {
			let arrayLoc = calcArrayLocfromPixelLoc(
					event.offsetX, event.offsetY,
					this.activeThermalArrayModel.arrayWidth(),
					this.activeThermalArrayModel.arrayHeight(),
					this.activeThermalImageView.canvasWidth(),
					this.activeThermalImageView.canvasHeight());
			this.activeToolModel.mouseDown(arrayLoc.x, arrayLoc.y);
		}
	}
	mouseIn(event) {
		if(this.activeToolModel) {
			this.activeToolModel.mouseIn();
		}
	}
	mouseOut(event) {
		if(this.activeToolModel) {
			this.activeToolModel.mouseOut();
		}
	}
	mouseMove(event) {
		if(this.activeToolModel && this.activeThermalArrayModel) {
			let arrayLoc = calcArrayLocfromPixelLoc(
					event.offsetX, event.offsetY,
					this.activeThermalArrayModel.arrayWidth(),
					this.activeThermalArrayModel.arrayHeight(),
					this.activeThermalImageView.canvasWidth(),
					this.activeThermalImageView.canvasHeight());
			this.activeToolModel.mouseMove(arrayLoc.x, arrayLoc.y);
		}
	}
	keyboard(event) {
		if(this.activeToolModel) {
			this.activeToolModel.keyboard();
		}
	}
}

class AnalysisTool extends EventEmitter{
	static name() {return "Analysis Tool";}
	mouseWheel(deltaX, deltaY) {;}
	mouseUp(mouseX, mouseY) {;}
	mouseDown(mouseX, mouseY) {;}
	mouseIn() {;}
	mouseOut() {;}
	mouseMove(mouseX, mouseY) {;}
	keyboard(key) {;}
	setArray(thermalArray) {;}
	getToolGraphics() {return [];}
	setActiveColorPaletteModel(colorPaletteModel) {
		this.activeColorPaletteModel=colorPaletteModel;
		this.draw();
	}
	draw() {
		if(this.activeColorPaletteModel && this.thermalArray) {
			this.emit('draw',{});
		}
	}
}
class PointerTool extends AnalysisTool {
	static name() {return "Pointer Tool";}
	constructor() {
		super();
		this.activeColorPaletteModel=null;
		this.boxWidth=3;
		this.boxHeight=3;
		this.mouseX=null;
		this.mouseY=null;
		this.dragging=false;
		this.thermalArray=null;
		this.analytics={};
		this.histNumBins=15;
	}

	mouseWheel(deltaX, deltaY) {
		if(deltaY < 0) {
			this.boxWidth+=1;
			this.boxHeight+=1;
			this.calculateAnalytics();
			this.draw();
		}
		else if(deltaY > 0 && this.boxWidth>3) {
			this.boxWidth-=1;
			this.boxHeight-=1;
			this.calculateAnalytics();
			this.draw();
		}
	}
	mouseUp(mouseX, mouseY) {
		this.dragging=false;
	}
	mouseDown(mouseX, mouseY) {
		this.dragging=true;
	}
	mouseIn() {;}
	mouseOut() {
		this.dragging=false;
	}
	mouseMove(mouseX, mouseY) {
		if(this.dragging && this.thermalArray) {
			if(this.mouseX!=mouseX || this.mouseY!=mouseY)
			{
				this.mouseX=mouseX;
				this.mouseY=mouseY;
				this.calculateAnalytics();
				this.draw();
			}
		}
	}
	setArray(thermalArray) {
		this.thermalArray=thermalArray;
		this.calculateAnalytics();
		this.draw();
	}
	calculateAnalytics() {
		if(this.mouseX===null || this.mouseY===null) {
			this.mouseY=Math.floor(this.thermalArray.length/2);
			this.mouseX=Math.floor(this.thermalArray[0].length/2);
		}
		const x0 = this.mouseX-this.boxWidth;
		const x1 = this.mouseX+this.boxWidth;
		const y0 = this.mouseY-this.boxHeight;
		const y1 = this.mouseY+this.boxHeight;
		let cursorArray = getSubArray(this.thermalArray, x0, x1, y0, y1);
		let minTemp = {
			t: Infinity,
			x: -1,
			y: -1
		};
		let maxTemp = {
			t: -Infinity,
			x: -1,
			y: -1
		};
		let sumTemps=0;
		let numTemps=0;
		for (let i = 0; i < cursorArray.length; i++) {
			for (let j = 0; j < cursorArray[i].length; j++) {
				const value = cursorArray[i][j];
				if (typeof value.t === 'number') {
					sumTemps += value.t;
					numTemps += 1;
					if (value.t < minTemp.t) {
						minTemp.t = value.t;
						minTemp.x = value.x;
						minTemp.y = value.y;
					}
					if (value.t > maxTemp.t) {
						maxTemp.t = value.t;
						maxTemp.x = value.x;
						maxTemp.y = value.y;
					}
				}
			}
		}
		this.analytics.minTemp=minTemp;
		this.analytics.maxTemp=maxTemp;
		this.analytics.avgTemp=sumTemps/numTemps;
		this.analytics.cursorArray=cursorArray;
		this.analytics.boxW=this.boxWidth;
		this.analytics.boxH=this.boxHeight;
		this.analytics.cursorX=this.mouseX;
		this.analytics.cursorY=this.mouseY;
		this.analytics.thermalArray = this.thermalArray;
	}

	getToolGraphics() {
		let toolImageGraphics=[];
		//Inner box
		let centerBox={type:'box', 
				x:this.analytics.cursorX, y:this.analytics.cursorY,
				w:0, h:0, 
				color:'black', stroke:'thin', mode:'inner'};
		let windowBox={type:'box', 
				x:this.analytics.cursorX, y:this.analytics.cursorY,
				w:this.analytics.boxW, h:this.analytics.boxH, 
				color:'black', stroke:'bold', mode:'outer'};
		let minBox={type:'box', 
				x:this.analytics.minTemp.x, y:this.analytics.minTemp.y,
				w:0, h:0, 
				color:'blue', stroke:'normal', mode:'outer'};
		let maxBox={type:'box', 
				x:this.analytics.maxTemp.x, y:this.analytics.maxTemp.y,
				w:0, h:0, 
				color:'red', stroke:'normal', mode:'outer'};
		toolImageGraphics.push(centerBox);
		toolImageGraphics.push(windowBox);
		toolImageGraphics.push(minBox);
		toolImageGraphics.push(maxBox);
		return toolImageGraphics;
	}

	getAnalyticsGraphics() {
		let analyticsGraphics=[];
		//Create histogram information
		//Flatten the 2D array
		let histogramArray=[];
		const tempArray = this.analytics.cursorArray;
		for (let i = 0; i < tempArray.length; i++) {
			for (let j = 0; j < tempArray[i].length; j++) {
				if (typeof tempArray[i][j].t === 'number') {
					histogramArray.push(tempArray[i][j].t)
				}
			}
		}
		// Calculate min and max values
		const histMin = Math.min(...histogramArray);
		const histMax = Math.max(...histogramArray);
		// Calculate bin size
		const binSize = (histMax - histMin) / this.histNumBins;
		// Initialize an array for bin counts
		let histBins = new Array(this.histNumBins).fill(null).map(() =>
				({count:0, color:'black', t0:0, t1:0, h:0}));
		// Populate histBins
		for (let i=0; i<histogramArray.length; i++) {
			const value = histogramArray[i];
			const binIndex = Math.min(
					Math.floor((value - histMin) / binSize), 
					this.histNumBins - 1);
			histBins[binIndex].count++;
		}
		// Add extra data to histbins
		for (let i=0; i<histBins.length; i++) {
			histBins[i].t0 = (i*binSize) + histMin;
			histBins[i].t1 = ((1+i)*binSize) + histMin;
			histBins[i].h = histBins[i].count / histogramArray.length;
			histBins[i].color = 'black';
		}
		//Create the gradient color array
		const gradientArray = this.activeColorPaletteModel.getGradientArray(
				this.analytics.minTemp.t, this.analytics.maxTemp.t);
		//compile the histogram instruction
		analyticsGraphics.push({type:'histogram', 
				histBins:histBins,
				color:{type:'gradient', gradient:gradientArray}});
		//Add scalar text values
		analyticsGraphics.push({type:'analysisInfo',
				min:this.analytics.minTemp.t,
				max:this.analytics.maxTemp.t,
				avg:this.analytics.avgTemp});
		return analyticsGraphics;
	}
}
class ProfileTool extends AnalysisTool {
	static name() {return "Profile Tool";}
	constructor() {
		super();
		console.log("ProfileTool: construct");
		this.width=1;
		this.mouseX = 0;
		this.mouseY = 0;
		this.startX=null;
		this.startY=null;
		this.endX=null;
		this.endY=null;
		this.dragging=false;
		this.thermalArray=null;
		this.analytics={};
		this.histNumBins=10;
	}

	mouseWheel(deltaX, deltaY) {
	}
	mouseUp(mouseX, mouseY) {
		this.dragging=false;
	}
	mouseDown(mouseX, mouseY) {
		this.dragging=true;
		this.startX=mouseX;
		this.startY=mouseY;
	}
	mouseIn() {;}
	mouseOut() {
		this.dragging=false;
	}
	mouseMove(mouseX, mouseY) {
		if(this.thermalArray) {
			if(this.dragging) {
				if(this.endX!=mouseX || this.endY!=mouseY)
				{
					this.endX=mouseX;
					this.endY=mouseY;
					this.calculateAnalytics();
					this.draw();
				}
			}
		}
	}
	setArray(thermalArray) {
		this.thermalArray=thermalArray;
		this.calculateAnalytics();
		this.draw();
	}
	calculateAnalytics() {
		if(this.startX===null || this.startY===null) {
			this.startX=2;
			this.startY=Math.floor(this.thermalArray.length/2);
			this.endX=this.thermalArray[0].length - 3;
			this.endY=this.startY;
		}
		const x0 = this.startX;
		const x1 = this.endX;
		const y0 = this.startY;
		const y1 = this.endY;
		let profileThermalArray = getLineArray(this.thermalArray, x0, x1, y0, y1);
		let minTemp = {
			t: Infinity,
			x: -1,
			y: -1
		};
		let maxTemp = {
			t: -Infinity,
			x: -1,
			y: -1
		};
		let sumTemps=0;
		let numTemps=0;
		for (let i = 0; i < profileThermalArray.length; i++) {
			const value = profileThermalArray[i];
			if (typeof value.t === 'number') {
				sumTemps += value.t;
				numTemps += 1;
				if (value.t < minTemp.t) {
					minTemp.t = value.t;
					minTemp.x = value.x;
					minTemp.y = value.y;
				}
				if (value.t > maxTemp.t) {
					maxTemp.t = value.t;
					maxTemp.x = value.x;
					maxTemp.y = value.y;
				}
			}
		}
		this.analytics.startX=this.startX;
		this.analytics.startY=this.startY;
		this.analytics.minTemp=minTemp;
		this.analytics.maxTemp=maxTemp;
		this.analytics.avgTemp={t:sumTemps/numTemps};
		this.analytics.cursorArray=profileThermalArray;
		this.analytics.thermalArray = this.thermalArray;
	}

	getToolGraphics() {
		let toolImageGraphics=[];
		//highlight pixels along the line that aren't the min/max
		for (let i = 0; i < this.analytics.cursorArray.length; i++) {
			const cursorPoint = this.analytics.cursorArray[i];
			if((cursorPoint.x == this.analytics.minTemp.x &&
					cursorPoint.y == this.analytics.minTemp.y) ||
					(cursorPoint.x == this.analytics.maxTemp.x &&
					cursorPoint.y == this.analytics.maxTemp.y) ||
					(cursorPoint.x == this.analytics.startX &&
					cursorPoint.y == this.analytics.startY)) {
				continue;
			} else {
				toolImageGraphics.push({type:'box', 
					x:cursorPoint.x, y:cursorPoint.y,
					w:0, h:0, 
					color:'black', stroke:'thin', mode:'inner'});
			}
		}
		//add the mintemp highlight
		toolImageGraphics.push({type:'box',
				x:this.analytics.minTemp.x, y:this.analytics.minTemp.y,
				w:0, h:0, 
				color:'blue', stroke:'normal', mode:'outer'});
		//add the maxtemp highlight
		toolImageGraphics.push({type:'box',
				x:this.analytics.maxTemp.x, y:this.analytics.maxTemp.y,
				w:0, h:0, 
				color:'red', stroke:'normal', mode:'outer'});
		//add startpoint highlight
		toolImageGraphics.push({type:'box',
				x:this.analytics.startX, y:this.analytics.startY,
				w:0, h:0, 
				color:'black', stroke:'normal', mode:'outer'});
		return toolImageGraphics;
	}

	getAnalyticsGraphics() {
		let analyticsGraphics=[];
		let profileArray = []
		for(let i=0; i<this.analytics.cursorArray.length; i++) {
			let h = Math.sqrt((this.analytics.startX - this.analytics.cursorArray[i].x)**2 +
					(this.analytics.startY - this.analytics.cursorArray[i].y)**2);
			profileArray.push({h:h, t:this.analytics.cursorArray[i].t});
		}
		profileArray=profileArray.sort((a,b) => a.h - b.h);
		const gradientArray = this.activeColorPaletteModel.getGradientArray(
				this.analytics.minTemp.t, this.analytics.maxTemp.t);
		//compile the histogram instruction
		analyticsGraphics.push(
				{type:'profile', 
				profileArray:profileArray,
				color:{type:'gradient', gradient:gradientArray}});
		analyticsGraphics.push({type:'analysisInfo',
				min:this.analytics.minTemp.t,
				max:this.analytics.maxTemp.t,
				avg:this.analytics.avgTemp.t});
		return analyticsGraphics;
	}
}

class CanvasGraphicsView extends EventEmitter{
	constructor(canvasId) {
		super();
		this.canvas = document.getElementById(canvasId);
	}

	canvasWidth() {
		return this.canvas.width;
	}

	canvasHeight() {
		return this.canvas.height;
	}

	setSize(canvasWidth, canvasHeight) {
		if(this.canvas.width!=canvasWidth ||
				this.canvas.height!=canvasHeight) {
			this.canvas.width = canvasWidth;
			this.canvas.height = canvasHeight;
			this.emit('draw',{});
		}
	}

	clearCanvas() {
		const canvasCtx = this.canvas.getContext('2d');
		canvasCtx.clearRect(0,0,this.canvas.width, this.canvas.height);
	}

	drawBox(instruction) {
		const boxX = instruction.x;
		const boxY = instruction.y;
		const boxW = instruction.w;
		const boxH = instruction.h;
		let boxStroke = 1;
		switch(instruction.stroke) {
			case 'bold':
				boxStroke=3;
				break;
			case 'thin':
				boxStroke=1;
				break;
			case 'normal':
				boxStroke=2;
				break;
		}
		const boxColor = instruction.color;
		const pixelScaleX = instruction.pixelScale.x;
		const pixelScaleY = instruction.pixelScale.y;
		const canvasCtx = this.canvas.getContext('2d');

		canvasCtx.strokeStyle=boxColor;
		canvasCtx.lineWidth=boxStroke;
		switch(instruction.mode) {
			case 'inner':
				canvasCtx.strokeRect(
				((boxX-boxW)*pixelScaleX), 
				((boxY-boxH)*pixelScaleY), 
				(((2*boxW)+1)*pixelScaleX), 
				(((2*boxH)+1)*pixelScaleY));
				break;

			case 'outer':
				canvasCtx.strokeRect(
				((boxX-boxW)*pixelScaleX)-Math.floor(boxStroke/2), 
				((boxY-boxH)*pixelScaleY)-Math.floor(boxStroke/2), 
				(((2*boxW)+1)*pixelScaleX)+boxStroke, 
				(((2*boxH)+1)*pixelScaleY)+boxStroke);
				break;
		}
	}

	drawPixelArray(instruction) {
		const pixelArray = instruction.pixelArray;
		const pixelScaleX = instruction.pixelScale.x;
		const pixelScaleY = instruction.pixelScale.y;
		const arrayHeight = pixelArray.length;
		const arrayWidth = pixelArray[0].length;
		const canvasCtx = this.canvas.getContext('2d');

		//Render each element of the array as a rectangle
		//Rectangle has sides according to widthpixelscale / heightpixelscale
		for (let y = 0; y < arrayHeight; y++) {
			for (let x = 0; x < arrayWidth; x++) {
				const pixelColor = pixelArray[y][x];
				canvasCtx.fillStyle = pixelColor;
				canvasCtx.fillRect(
						x*pixelScaleX, 
						y*pixelScaleY, 
						pixelScaleX, 
						pixelScaleY);
			}
		}
	}

	draw(drawInstructions) {
		this.clearCanvas();
		for (let instruction of drawInstructions) {
			switch(instruction.type) {
				case 'pixelarray':
					this.drawPixelArray(instruction);
					break;
				case 'box':
					this.drawBox(instruction);
					break;
			}
		}
	}
}
class ThermalImageView extends CanvasGraphicsView {

}
class ToolView extends CanvasGraphicsView {

}

class AnalysisView extends EventEmitter{
	constructor(divId) {
		super();
		this.div = document.getElementById(divId);
		this.template = document.getElementById("id_genericAnalysisTemplate");
		this.drawCanvas = document.createElement('canvas');
		this.colorCanvas = document.createElement('canvas');
		this.gap = 2;
	}

	display() {
		this.div.innerHTML = this.template.innerHTML;
		this.canvas = document.getElementById("id_analysisCanvas");
		this.drawCanvas.width = this.canvas.width;
		this.drawCanvas.height = this.canvas.height;
		this.colorCanvas.width = this.canvas.width;
		this.colorCanvas.height = this.canvas.height;
		this.minSpan = document.getElementById("id_analysisMin");
		this.maxSpan = document.getElementById("id_analysisMax");
		this.avgSpan = document.getElementById("id_analysisAvg");
	}

	hide() {
		this.div.innerHTML = "";
	}

	divWidth() {
		return this.div.offsetWidth;
	}

	divHeight() {
		return this.div.offsetHeight;
	}

	resizeUpdate() {
		this.canvas.width = this.canvas.parentElement.clientWidth;
		this.canvas.height = this.canvas.parentElement.clientHeight;
		this.drawCanvas.width = this.canvas.width;
		this.drawCanvas.height = this.canvas.height;
		this.colorCanvas.width = this.canvas.width;
		this.colorCanvas.height = this.canvas.height;
		this.emit('draw',{});
	}

	numberToFixedWidthString(number, mode="round") {
		const absNumber = Math.abs(number);
		let numStr = "";
		let numFloat = 0.0;
		let roundFn = null;
		switch(mode) {
		case "up":
			roundFn = Math.ceil;
			break;
		case "round":
			roundFn = Math.round;
			break;
		case "down":
			roundFn = Math.floor;
			break;
		}
		if(absNumber < 10) {
			numFloat = roundFn(number*1000)/1000;
			numStr = numFloat.toFixed(3);
			
		} else if(absNumber < 100) {
			numFloat = roundFn(number*100)/100;
			numStr = numFloat.toFixed(2);
			
		} else if(absNumber < 1000 ) {
			numFloat = roundFn(number*10)/10
			numStr = numFloat.toFixed(1);
			
		} else if(absNumber < 10000) {
			numFloat = roundFn(number/100)*10000;
			numStr = (numFloat/1000).toFixed(2)+"K";
			
		} else {
			numFloat = roundFn(number/100000)*10000000;
			numStr = (numFloat/1000000).toFixed(2)+"M";
		}
		return {label:numStr, float:numFloat};
	}

	createGraphAxis(xMin, xMax, yMin, yMax, 
			xTicks=0, xGridlines=0, yTicks=0, yGridlines=0) {
		const canvasHeight = this.canvas.height;
		const canvasWidth = this.canvas.width;
		const canvasCtx = this.canvas.getContext('2d');
		canvasCtx.font = 
				`${g_AnalysisGraph_FontSize}px ${g_AnalysisGraph_Font} sans-serif`;
		const labelChars = canvasCtx.measureText("-0.000");
		const labelWidth = labelChars.width + this.gap;
		const labelHeight = g_AnalysisGraph_FontSize + this.gap;
		//Determine dimensions of X axis
		const x0 = labelWidth;
		const xSections = (xTicks+1)*(xGridlines+1);
		const xLen = 
				Math.floor(((canvasWidth-this.gap)-x0)/xSections)
				* xSections;
		const x1 = x0 + xLen;
		const xTickLen = xLen / (xTicks+1);
		const xTickSize = (xMax - xMin) / (xTicks+1);
		const xGridLen = xLen / (xGridlines+1);
		const xGridSize = (xMax - xMin) / (xGridlines+1);
		//Determine dimensions of Y axis
		const y0 = canvasHeight-labelHeight;
		const ySections = (yTicks+1)*(yGridlines+1);
		const yLen = 
				Math.floor((y0-this.gap)/ySections)
				* ySections;
		const y1 = this.gap;
		const yTickLen = yLen / (yTicks+1);
		const yTickSize = (yMax - yMin) / (yTicks+1);
		const yGridLen = yLen / (yGridlines+1);
		const yGridSize = (yMax - yMin) / (yGridlines+1);
		//Draw graph bounding box
		canvasCtx.beginPath();
		canvasCtx.moveTo(x0, y0);
		canvasCtx.lineTo(x0, y1);
		canvasCtx.lineTo(x1, y1);
		canvasCtx.lineTo(x1, y0);
		canvasCtx.lineTo(x0, y0);
		canvasCtx.stroke();
		//Add min and max labels to X and Y axis
		const xMinLabel = this.numberToFixedWidthString(xMin);
		canvasCtx.fillText(xMinLabel.label,x0,canvasHeight);
		const xMaxLabel = this.numberToFixedWidthString(xMax);
		canvasCtx.fillText(xMaxLabel.label,x1-labelWidth,canvasHeight);
		const yMinLabel = this.numberToFixedWidthString(yMin);
		canvasCtx.fillText(yMinLabel.label,0,y0);
		const yMaxLabel = this.numberToFixedWidthString(yMax);
		canvasCtx.fillText(yMaxLabel.label,0,y1+labelHeight);
		//Draw the x ticks/labels
		for(let i=1; i<xTicks+1; i++) {
			const tickLoc = (i*xTickLen)+x0;
			const tickLabel = this.numberToFixedWidthString((xTickSize*i)+xMin);
			canvasCtx.fillText(tickLabel.label,tickLoc,canvasHeight);
		}
		//Draw the y ticks/labels
		for(let i=1; i<yTicks+1; i++) {
			const tickLoc = y0 - (i*yTickLen);
			const tickLabel = this.numberToFixedWidthString((yTickSize*i)+yMin);
			canvasCtx.fillText(tickLabel.label,0,tickLoc);
		}
		//Draw the x gridlines (vertical gridlines)
		canvasCtx.beginPath();
		for(let i=1; i<xGridlines+1; i++) {
			const gridLoc = (i*xGridLen)+x0;
			canvasCtx.moveTo(gridLoc, y0);
			canvasCtx.lineTo(gridLoc, y1);
		}
		canvasCtx.stroke();
		//Draw the y gridlines (horizontal gridlines)
		canvasCtx.beginPath();
		for(let i=1; i<yGridlines+1; i++) {
			const gridLoc = y0-(i*yGridLen);
			canvasCtx.moveTo(x0, gridLoc);
			canvasCtx.lineTo(x1, gridLoc);
		}
		canvasCtx.stroke();
		return {x0:x0, x1:x1, y0:y0, y1:y1};
	}

	drawHistogram(instruction) {
		const canvasHeight = this.canvas.height;
		const canvasWidth = this.canvas.width;
		const canvasCtx = this.canvas.getContext('2d');
		const drawCtx = this.drawCanvas.getContext('2d');
		const colorCtx = this.colorCanvas.getContext('2d');
		// Clear canvas
		canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);
		colorCtx.clearRect(0,0,canvasWidth,canvasHeight);
		drawCtx.clearRect(0,0,canvasWidth,canvasHeight);
		//Sort the hist bins from low to high bin limit
		const histBins = instruction.histBins.sort((a,b)=>{return a.t0-b.t0;});
		//Find min/max bin temperatures and heights
		let maxT1 = -Infinity;
		let minT0 = Infinity;
		let maxH = -Infinity;
		let minH = 0.0;
		for(let i=0; i<histBins.length; i++) {
			if(histBins[i].t1 > maxT1) {
				maxT1 = histBins[i].t1;
			}
			if(histBins[i].t0 < minT0) {
				minT0 = histBins[i].t0;
			}
			if(histBins[i].h > maxH) {
				maxH = histBins[i].h;
			}
		}
		maxH = Math.ceil(maxH / 0.2)*0.2;
		//Create axis
		const numBins = histBins.length;
		const graph = this.createGraphAxis(minT0,maxT1,minH,maxH,
				numBins-1,0,2,2);
		//Draw the histogram
		const binWidth = Math.floor((graph.x1-graph.x0)/numBins);
		const binYScale = Math.floor((graph.y0-graph.y1)/maxH);
		//Prepare to draw the graph
		drawCtx.fillStyle='black';
		drawCtx.strokeStyle='black';
		//Configre the color canvas
		if(instruction.color.type=='solid') {
			colorCtx.fillStyle=instruction.color.color;
		} 
		else if(instruction.color.type=='gradient') {
			let gradient = 
					colorCtx.createLinearGradient(graph.x0, 0, 
					graph.x1, 0);
			for(let i=0; i<instruction.color.gradient.length; i++) {
				gradient.addColorStop(instruction.color.gradient[i].offset,
						instruction.color.gradient[i].color);
			}
			colorCtx.fillStyle=gradient;
		} 
		else {
			colorCtx.fillStyle='black';
		}
		colorCtx.fillRect(0,0,canvasWidth,canvasHeight);
		//Draw the histrogram
		for(let i=0; i<histBins.length; i++) {
			const binX0 = Math.floor(graph.x0+(binWidth*i))+1;
			const binY0 = graph.y0;
			const binHeight = Math.floor(histBins[i].h*binYScale);
			//canvasCtx.fillStyle = histBins[i].color;
			//draw the bin with 2-pixel gap between bins
			drawCtx.fillRect(binX0, binY0-binHeight, binWidth-2, binHeight);
		}
		//copy drawing over to viewable canvas
		colorCtx.globalCompositeOperation = 'destination-in';
		colorCtx.drawImage(this.drawCanvas,0,0);
		colorCtx.globalCompositeOperation = 'source-over';
		canvasCtx.drawImage(this.colorCanvas,0,0);
	}

	drawProfile(instruction) {
		const canvasHeight = this.canvas.height;
		const canvasWidth = this.canvas.width;
		const canvasCtx = this.canvas.getContext('2d');
		const drawCtx = this.drawCanvas.getContext('2d');
		const colorCtx = this.colorCanvas.getContext('2d');
		// Clear canvas
		canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);
		colorCtx.clearRect(0,0,canvasWidth,canvasHeight);
		drawCtx.clearRect(0,0,canvasWidth,canvasHeight);
		//Get relevant values from instruction
		const profileArray = instruction.profileArray;
		//Determine the min and max temperatures
		let maxTemp = -Infinity;
		let minTemp = Infinity;
		let maxH = -Infinity;
		let minH = Infinity;
		for(let i=0; i<profileArray.length; i++) {
			if(profileArray[i].t > maxTemp) {
				maxTemp = profileArray[i].t;
			}
			if(profileArray[i].t < minTemp) {
				minTemp = profileArray[i].t;
			}
			if(profileArray[i].h > maxH) {
				maxH = profileArray[i].h;
			}
			if(profileArray[i].h < minH) {
				minH = profileArray[i].h;
			}
		}
		//Create axis
		const graph = this.createGraphAxis(minH,maxH,minTemp,maxTemp,
				0,0,2,5);
		const xScale = (graph.x1-graph.x0)/(maxH-minH);
		const yScale = (graph.y0-graph.y1)/(maxTemp-minTemp);
		//Prepare to draw profile
		drawCtx.fillStyle='black';
		drawCtx.strokeStyle='black';
		drawCtx.lineWidth=2;
		//Setup color canvas
		if(instruction.color.type=='solid') {
			colorCtx.fillStyle=instruction.color.color;
		} 
		else if(instruction.color.type=='gradient') {
			let gradient = 
					colorCtx.createLinearGradient(0, graph.y0, 
					0, graph.y1);
			for(let i=0; i<instruction.color.gradient.length; i++) {
				gradient.addColorStop(instruction.color.gradient[i].offset,
						instruction.color.gradient[i].color);
			}
			colorCtx.fillStyle=gradient;
		} 
		else {
			colorCtx.fillStyle='black';
		}
		colorCtx.fillRect(0,0,canvasWidth,canvasHeight);
		//Draw the profile line
		drawCtx.beginPath();
		drawCtx.moveTo(
				(graph.x0+(xScale*(profileArray[0].h-minH))), 
				(graph.y0-(yScale*(profileArray[0].t-minTemp)))
				);
		for(let i=1; i<profileArray.length-1; i++) {
			drawCtx.lineTo(
					(graph.x0+(xScale*(profileArray[i].h-minH))), 
					(graph.y0-(yScale*(profileArray[i].t-minTemp)))
					);
		}
		drawCtx.stroke();
		//copy drawing over to viewable canvas
		colorCtx.globalCompositeOperation = 'destination-in';
		colorCtx.drawImage(this.drawCanvas,0,0);
		colorCtx.globalCompositeOperation = 'source-over';
		canvasCtx.drawImage(this.colorCanvas,0,0);
	}

	drawAnalysisInfo(instruction) {
		this.minSpan.innerHTML = instruction.min;
		this.maxSpan.innerHTML = instruction.max;
		this.avgSpan.innerHTML = instruction.avg;
	}

	draw(drawInstructions) {
		for (let instruction of drawInstructions) {
			switch(instruction.type) {
				case 'histogram':
					this.drawHistogram(instruction);
					break;
				case 'profile':
					this.drawProfile(instruction);
					break;
				case 'analysisInfo':
					this.drawAnalysisInfo(instruction);
					break;
			}
		}
	}
}

class ThermalArrayModel extends EventEmitter{
	constructor() {
		super();
		console.log("ThermalArrayModel: make array model");
		this.name="";
		this.thermalArray=[];
		this.thermalFileModel = new ThermalFileModel();
		this.activeColorPaletteModel = null;
	}

	arrayWidth() {
		return this.thermalArray[0].length;
	}

	arrayHeight() {
		return this.thermalArray.length;
	}

	getThermalArray() {
		return this.thermalArray;
	}

	getThermalImage() {
		let thermalImageArray = [];
		//Find min and max values of temperature array
		if(this.thermalArray) {
			this.activeColorPaletteModel.initializePalette(this.thermalArray);
			for (let row of this.thermalArray) {
				let thermalRow =[]
				for (let value of row) {
					if (!isNaN(value)) {
						thermalRow.push(
								this.activeColorPaletteModel.getColorForValue(value));
					} else {
						thermalRow.push(this.activeColorPaletteModel.nullColor());
					}
				}
				thermalImageArray.push(thermalRow);
			}
		}
		let graphicsInstructions = [{type:'pixelarray',
				pixelArray:thermalImageArray}];
		return graphicsInstructions;
	}

	getThermalPreview() {
		return this.thermalFileModel.dataUrl;
	}

	parseFile(irFile) {
		return new Promise((resolve, reject) => {
			this.thermalFileModel.loadFile(irFile).then(() => {
				this.createThermalArray();
				this.name=this.thermalFileModel.fileName;
				resolve();
			}).catch((error) => {
				reject(new Error(error));
			});
		});
	}

	setActiveColorPaletteModel(colorPaletteModel) {
		this.activeColorPaletteModel=colorPaletteModel;
		this.emit('draw',{});
	}

	createThermalArray() {
		const rawData=this.thermalFileModel.dataFLIR.rawData;
		const cameraData=this.thermalFileModel.dataFLIR.cameraData;
		if(!rawData || !cameraData) {
			throw "Did not find raw camera data";
		}
		this.thermalArray=[];
		if(rawData['ThermalImage'].length < 
				(rawData['ImageHeight'] * rawData['ImageWidth'])) {
			throw "ThermalImage has wrong length (not Height * Width)";
		}
		this.arrayRendered=false;
		const e = Math.E;
			const R1 = cameraData[ 'PlanckR1'];
			const R2 = cameraData[ 'PlanckR2'];
			const B = cameraData[ 'PlanckB'];
			const F = cameraData[ 'PlanckF'];
			const O = cameraData[ 'PlanckO'];
			const T_refl = cameraData[ 'ReflectedApparentTemperature'];
			const Emissivity = cameraData[ 'Emissivity'];

		for (let h=0; h<rawData['ImageHeight']; h++) {
			let row=[];
			let rowOffset = h*rawData['ImageWidth'];
			for (let w=0; w<rawData['ImageWidth']; w++) {
					const S = rawData['ThermalImage'][rowOffset+w];
					const RAW_refl = R1 / (R2 * (Math.pow(e, B/T_refl) - F)) - O;
					const RAW_obj = (S - (1 - Emissivity) * RAW_refl) / Emissivity;
					const T_obj = B / Math.log(R1 / (R2 * (RAW_obj + O)) + F);
					row.push(T_obj);
			}
			this.thermalArray.push(row)
		}
		this.emit('draw',{});
	}
}

class ThermalFileModel extends EventEmitter{
	constructor() {
		super();
		this.byteArray=null;
		this.dataUrl=null;
		this.fileName="";
		this.segmentList=[];
		this.bytesFLIR=[];
		this.headerFLIR={};
		this.recordsFLIR={};
		this.dataFLIR={};
	}

	loadFile(irFile) {
		return new Promise((resolve, reject) => {
			let byteArrayReader = new FileReader();
			byteArrayReader.onloadend = () => {
				if (byteArrayReader.result) {
					this.byteArray = new Uint8Array(byteArrayReader.result);
					this.parseFile();
					let dataUrlReader = new FileReader();

					dataUrlReader.onloadend = () => {
						if (dataUrlReader.result) {
							this.dataUrl = dataUrlReader.result;
							this.fileName = irFile.name;
							resolve();
						}
					};
					dataUrlReader.onerror = (error) => {
						reject(new Error(error));
					}
					dataUrlReader.readAsDataURL(irFile);
				}
			};
			byteArrayReader.onerror = (error) => {
				reject(new Error(error));
			}
			byteArrayReader.readAsArrayBuffer(irFile);
		});
	}

	parseFile() {
		console.log("ThermalFileModel: find segments");
		this.findSegments();
		console.log("ThermalFileModel: extract FLIR segments");
		this.extractFLIRSegments();
		console.log("ThermalFileModel: process FLIR header");
		this.processFLIRHeader();
		console.log("ThermalFileModel: process FLIR records");
		this.processFLIRRecords();
		console.log("ThermalFileModel: process Raw Data");
		this.processRawData();
		console.log("ThermalFileModel: process Camera Data");
		this.processCameraData();
	}

	findSegments() {
		let i = 0;
		let found_exif = false;
		this.segmentList=[];
		//check that it's a valid jpeg (starts with 0xD8FF)
		if (this.byteArray[i] !== 0xFF || this.byteArray[i + 1] !== 0xD8) {
			throw "Not a valid JPEG file";
		}
		i += 2;
		//create list of all jpeg segments 
		//	(segments starts with 0xFFyy where yy isn't 0x00)
		//the list is like [[segment id, segment start index,segment length]]
		while (i < this.byteArray.length) {
			if(this.byteArray[i] == 0xFF){
				if(this.byteArray[i+1] != 0x00){
					let segment_info=[];
					let segment_id = this.byteArray[i + 1];
					if(segment_id==225) {
						found_exif=true;
					}
					let segment_start = i+2;
					let segment_length = 0;
					segment_info.push(segment_id);
					segment_info.push(segment_start)
					segment_length = (this.byteArray[segment_start] << 8) + 
							this.byteArray[segment_start+1];
					if(this.byteArray[segment_start+segment_length]==0xFF && 
							this.byteArray[segment_start+segment_length+1]!=0x00) {
						segment_info.push(segment_length);
						i = segment_start+segment_length;
					} else {
						segment_info.push(0);
						i+=2;
					}
					this.segmentList.push(segment_info);
				} else{i+=2;}
			} else{i+=1;}
		}
		if(!this.segmentList) {throw "Found no segments"}
		if(!found_exif) {throw "Found no EXIF segments"}
	}

	extractFLIRSegments() {
		//compile segments into flir data
		this.bytesFLIR = new Uint8Array([]);
		for(const segment_info of this.segmentList) {
			if(segment_info[0]==225 && segment_info[2]>=0x40) //check if exif segment and large enough for data
			{	
				//prepare to slice up start of segment for identification
				let segment_size_start=segment_info[1];
				let segment_type_start=segment_size_start+2;
				let segment_contents_start=segment_type_start+8; //flir records have 8 bytes of id at beginning
				let segment_size_bytes=segment_info[2];
				let segment_contents_size=segment_size_bytes-(2+8); //excluding 2 byte segment size and 8 byte id
				//Slice up array and determine if FLIR type
				let segment_type_bytes = this.byteArray.slice(segment_type_start, segment_type_start+6);
				let segment_type=""
				for(let i=0; i<6; i++){
					segment_type+=String.fromCharCode(segment_type_bytes[i]);
				}
				//Check that the segment tag is correct
				if(segment_type.startsWith("FLIR")){
					//combine this segment with previous flir segments
					let segment_contents_bytes=this.byteArray.slice(segment_contents_start, segment_contents_start+segment_contents_size);
					this.bytesFLIR = concatenateUint8Arrays(this.bytesFLIR, segment_contents_bytes);
				}
			}
		}
		if(!this.bytesFLIR) {
			throw "Found no FLIR segments"
		}
	}

	processFLIRHeader() 
	{
		if(this.bytesFLIR.length<0x40) {
			throw "FLIR segment is too small"
		}
		let header_bytes=this.bytesFLIR.slice(0, 0x40);
		if(String.fromCharCode(header_bytes[0])=="F" || 
				String.fromCharCode(header_bytes[0])=="A")
		{
			if(String.fromCharCode(header_bytes[1])=="F" 
				&& String.fromCharCode(header_bytes[2])=="F"
				&& header_bytes[3]==0)
			{
				this.headerFLIR={};
				this.headerFLIR['Creator']=getstring(header_bytes,0x04,16);
				this.headerFLIR['Version']=get32u(header_bytes,0x14);
				this.headerFLIR['RecordOffset']=get32u(header_bytes,0x18);
				this.headerFLIR['NumRecords']=get32u(header_bytes,0x1c);
				this.headerFLIR['NextIndex']=get32u(header_bytes,0x20);
				this.headerFLIR['SwapPattern']=get16u(header_bytes,0x24);
				this.headerFLIR['Spares']=get16u_array(header_bytes,0x28, 7);
				this.headerFLIR['Reserved']=get32u_array(header_bytes,0x34, 2);
				this.headerFLIR['Checksum']=get32u(header_bytes,0x3c);
				return;
			}
		}
		throw "FLIR header has invalid start code"
	}

	processFLIRRecords()
	{
		if(this.headerFLIR['NumRecords']>255) {
			throw "Number of records is invalid";
		}
		let records_start_index = this.headerFLIR['RecordOffset'];
		let records_end_index = records_start_index+
				(0x20 * this.headerFLIR['NumRecords']);
		if(records_end_index > this.bytesFLIR.length) {
			throw "FLIR records extend past end of records";
		}
		//Extract the record header sections
		this.bytesRecords=this.bytesFLIR.slice(records_start_index, records_end_index);
		//Extract information for each record
		this.recordsFLIR={}
		for(let i=0; i<this.headerFLIR['NumRecords']; ++i)
		{
			let record={}
			let record_start=i*0x20;
			record['Type']=get16u(this.bytesRecords,record_start+0x00);
			record['SubType']=get16u(this.bytesRecords,record_start+0x02);
			record['Version']=get32u(this.bytesRecords,record_start+0x04);
			record['IndexID']=get32u(this.bytesRecords,record_start+0x08);
			record['RecordOffset']=get32u(this.bytesRecords,record_start+0x0c);
			record['RecordLength']=get32u(this.bytesRecords,record_start+0x10);
			record['Parent']=get32u(this.bytesRecords,record_start+0x14);
			record['ObjectNumber']=get32u(this.bytesRecords,record_start+0x18);
			record['Checksum']=get32u(this.bytesRecords,record_start+0x1c);
			if(record['Type']==0) {
				continue;
			}
			else {
				this.recordsFLIR[record['Type']]=record;
			}
		}
	}

	processRawData()
	{
		if(!this.recordsFLIR.hasOwnProperty(0x01)) {
			throw "FLIR records missing key for raw data";
		}
		let reverse=false;
		let record=this.recordsFLIR[0x01];
		this.dataFLIR["rawData"]={};
		let raw_data={};
		raw_data['ByteOrder'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x00);
		if(raw_data['ByteOrder']>0x0100) {
			reverse=true;
		}
		raw_data['ByteOrder'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x00, reverse);
		raw_data['ImageWidth'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x02, reverse);
		raw_data['ImageHeight'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x04, reverse);
		raw_data['ThermalImage'] = 
		get16u_array(this.bytesFLIR, record['RecordOffset']+0x1E+2, 
				raw_data['ImageWidth']*raw_data['ImageHeight'], reverse)
		this.dataFLIR["rawData"] = raw_data;
	}

	processCameraData()
	{
		if(!this.recordsFLIR.hasOwnProperty(0x20)) {
			throw "FLIR records missing key for camera data";
		}
		let reverse=false;
		let record=this.recordsFLIR[0x20];
		this.dataFLIR["cameraData"]={};
		let camera_data={};
		camera_data['ByteOrder'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x00);
		if(camera_data['ByteOrder']>0x0100) {
			reverse=true;
		}
		camera_data[ 'ByteOrder'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x00, reverse);
		camera_data[ 'Emissivity'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x20, reverse);
		camera_data[ 'ObjectDistance'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x24, reverse);
		camera_data[ 'ReflectedApparentTemperature'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x28, reverse);
		camera_data[ 'AtmosphericTemperature'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x2c, reverse);
		camera_data[ 'IRWindowTemperature'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x30, reverse);
		camera_data[ 'IRWindowTransmission'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x34, reverse);
		camera_data[ 'RelativeHumidity'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x3c, reverse);
		camera_data[ 'PlanckR1'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x58, reverse);
		camera_data[ 'PlanckB'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x5c, reverse);
		camera_data[ 'PlanckF'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x60, reverse);
		camera_data[ 'AtmosphericTransAlpha1'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x070, reverse);
		camera_data[ 'AtmosphericTransAlpha2'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x074, reverse);
		camera_data[ 'AtmosphericTransBeta1'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x078, reverse);
		camera_data[ 'AtmosphericTransBeta2'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x07c, reverse);
		camera_data[ 'AtmosphericTransX'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x080, reverse);
		camera_data[ 'CameraTemperatureRangeMax'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x90, reverse);
		camera_data[ 'CameraTemperatureRangeMin'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x94, reverse);   
		camera_data[ 'CameraTemperatureMaxClip'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x98, reverse);  
		camera_data[ 'CameraTemperatureMinClip'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x9c, reverse);
		camera_data[ 'CameraTemperatureMaxWarn'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0xa0, reverse);
		camera_data[ 'CameraTemperatureMinWarn'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0xa4, reverse);
		camera_data[ 'CameraTemperatureMaxSaturated'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0xa8, reverse);
		camera_data[ 'CameraTemperatureMinSaturated'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0xac, reverse);  
		camera_data[ 'CameraModel'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0xd4, 32);
		camera_data[ 'CameraPartNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0xf4, 16, reverse);
		camera_data[ 'CameraSerialNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x104, 16, reverse);
		camera_data[ 'CameraSoftware'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x114, 16, reverse);
		camera_data[ 'LensModel'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x170, 32, reverse);
		camera_data[ 'LensPartNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x190, 16, reverse);
		camera_data[ 'LensSerialNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x1a0, 16, reverse);
		camera_data[ 'FieldOfView'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x1b4, reverse);
		camera_data[ 'FilterModel'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x1ec, 16, reverse);
		camera_data[ 'FilterPartNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x1fc, 32, reverse);
		camera_data[ 'FilterSerialNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x21c, 32, reverse);
		camera_data[ 'PlanckO'] = 
		get32s(this.bytesFLIR, record['RecordOffset']+0x308, reverse);
		camera_data[ 'PlanckR2'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x30c, reverse);
		camera_data[ 'RawValueRangeMin'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x310, reverse);
		this.dataFLIR["cameraData"] = camera_data;
	}
}

function getSubArray(array, x0, x1, y0, y1) {
	//Returns an subarray from Array from x0,y0 to x1,y1. 
	//Values outside the array are returned as null
	const subArray = [];
	for (let i = y0; i <= y1; i++) {
			const subRow = [];
			for (let j = x0; j <= x1; j++) {
					if (i >= 0 && i < array.length &&
								j >= 0 && j < (array[i] ? array[0].length : 0)) {
							subRow.push({y:i, x:j, t:array[i][j]});
					} 
					else {
							subRow.push({y:i, x:j, t:null});
					}
			}
			subArray.push(subRow);
	}
	return subArray;
}
function getLineArray(array, x0, x1, y0, y1) {
		let points = [];
		
		let dx = Math.abs(x1 - x0);
		let dy = Math.abs(y1 - y0);
		
		let sx = (x0 < x1) ? 1 : -1;
		let sy = (y0 < y1) ? 1 : -1;

		let err = dx - dy;

		while (true) {
				// Put the point into the array
				if (array[y0] && array[y0][x0] !== undefined) {
						points.push({x:x0, y:y0, t:array[y0][x0]});
				}

				if ((x0 === x1) && (y0 === y1)) break;
				let e2 = 2 * err;

				// EITHER move horizontally, OR move vertically, OR move in both directions
				if (e2 > -dy) { err -= dy; x0 += sx; }
				if (e2 < dx) { err += dx; y0 += sy; }
		}

		return points;
}
function get32float(array, offset, reverse=false) {
		const buffer = new ArrayBuffer(8);
		const view = new DataView(buffer);
		if(reverse) {
			view.setUint8(3,array[offset+0]);
			view.setUint8(2,array[offset+1]);
			view.setUint8(1,array[offset+2]);
			view.setUint8(0,array[offset+3]);
		} else {
			view.setUint8(0,array[offset]);
			view.setUint8(1,array[offset+1]);
			view.setUint8(2,array[offset+2]);
			view.setUint8(3,array[offset+3]);
		}    
		return view.getFloat32(0);
}
function get32u(array, offset, reverse=false) {
	if(reverse) {
		return array[offset+3]<<24 | array[offset+2]<<16 | 
				array[offset+1]<<8 | array[offset]<<0;
	}
	return array[offset]<<24 | array[offset+1]<<16 | 
			array[offset+2]<<8 | array[offset+3]<<0;
}
function get32s(array, offset, reverse=false) {
	//TODO
	//apparently get32u will return negative values already?
	return get32u(array, offset, reverse);
}
function get32u_array(array, offset, len, reverse=false) {
	let array_32u=[];
	for(let i=0; i<len; i++) {
		array_32u.push(get32u(array, offset+(4*i), reverse));
	}
	return array_32u;
}
function get16u(array, offset,reverse=false) {
	if(reverse) {
		return array[offset+1]<<8 | array[offset]<<0;
	}
	return array[offset]<<8 | array[offset+1]<<0;
}
function get16u_array(array, offset, len, reverse=false) {
	let array_16u=[];
	for(let i=0; i<len; i++) {
		array_16u.push(get16u(array, offset+(2*i), reverse));
	}
	return array_16u;
}
function getstring(array, offset, len, reverse=false) {
	let string="";
	for(let i=0; i<len; i++) {
		string+=String.fromCharCode(array[offset+i]);
	}
	return string;
}
function concatenateUint8Arrays(...arrays) {
		let totalLength = 0;
		for (let arr of arrays) {
				totalLength += arr.length;
		}
		let result = new Uint8Array(totalLength);
		let offset = 0;
		for (let arr of arrays) {
				result.set(arr, offset);
				offset += arr.length;
		}
		
		return result;
}
function calcCanvasSize(arrayWidth, arrayHeight, divWidth, divHeight) {
	const newHeight = Math.floor(divHeight/arrayHeight)*arrayHeight;
	const newWidth = Math.floor(divWidth/arrayWidth)*arrayWidth;
	return {width:newWidth, height:newHeight}
}
function calcGraphicPixelScale(drawInstructions, arrayWidth, arrayHeight, 
		canvasWidth, canvasHeight) {
	const pixelScaleX = Math.floor(canvasWidth/arrayWidth);
	const pixelScaleY = Math.floor(canvasHeight/arrayHeight);
	for (let instruction of drawInstructions) {
		instruction.pixelScale={x:pixelScaleX, y:pixelScaleY};
	}
	return drawInstructions;
}
function calcArrayLocfromPixelLoc(pixelX, pixelY, arrayWidth, arrayHeight, 
		canvasWidth, canvasHeight) {
	const arrayX = Math.floor(arrayWidth * pixelX / canvasWidth);
	const arrayY = Math.floor(arrayHeight * pixelY / canvasHeight);
	return {x:arrayX, y:arrayY};
}

class ColorPaletteModel extends EventEmitter{
	constructor() {
		super();
		this.minValue = 0;
		this.maxValue = 100;
		this.palette = [[0,0,0],[255,255,255]];
	}

	initializePalette(valueArray) {
		let minValue = Infinity;
		let maxValue = -Infinity;
		for (let row of valueArray) {
			if(Array.isArray(row)) {
				for (let value of row) {
					if (!isNaN(value)) {
						minValue = Math.min(minValue, value);
						maxValue = Math.max(maxValue, value);
					}
				}
			} else {
				if (!isNaN(value)) {
					minValue = Math.min(minValue, row);
					maxValue = Math.max(maxValue, row);
				}
			}
		}
		this.minValue = minValue;
		this.maxValue = maxValue;
	}

	changePaletteValue() {
		this.emit("palettechange",{});
	}

	nullColor() {
		return `rgb(0,0,0)`;
	}
	getColorForIndex(index) {
		const idx1 = Math.floor(index);
		const idx2 = Math.min(idx1 + 1, this.palette.length - 1);
		if (idx1 == idx2) {
				const color = this.palette[idx1];
				return `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
		}
		const t = index - idx1;
		const color1 = this.palette[idx1];
		const color2 = this.palette[idx2];
		const r = Math.round(color1[0] + (t * (color2[0]-color1[0])));
		const g = Math.round(color1[1] + (t * (color2[1]-color1[1])));
		const b = Math.round(color1[2] + (t * (color2[2]-color1[2])));
		return `rgb(${r}, ${g}, ${b})`;
	}

	getColorForValue(value) {
		let valueIndex = 0;
		if (value>this.maxValue) {
			valueIndex = this.palette.length - 1;
		} else if (value<this.minValue) {
			valueIndex = 0;
		}	else {
			valueIndex = (this.palette.length-1)*
					(value-this.minValue)/(this.maxValue-this.minValue);
		}
		return this.getColorForIndex(valueIndex);
	}
	getGradientArray(lowValue, highValue) {
		let lowIndex=0;
		if(lowValue>this.maxValue) {
			lowIndex=this.palette.length-1;
		} else if(lowValue<this.minValue) {
			lowIndex=0;
		}	else {
			lowIndex=(this.palette.length-1)*
					(lowValue-this.minValue)/(this.maxValue-this.minValue);
		}
		let highIndex=0;
		if (highValue>this.maxValue) {
			highIndex=this.palette.length-1;;
		} else if (highValue<this.minValue) {
			highIndex=0;
		}	else {
			highIndex=(this.palette.length-1)*
					(highValue-this.minValue)/(this.maxValue-this.minValue);
		}
		let gradientArray = [{offset:0, color:this.getColorForIndex(lowIndex)}];
		let indexRange = highIndex-lowIndex;
		for(let i=Math.floor(lowIndex)+1; i<highIndex; i++) {
			const offset = (i-lowIndex) / indexRange;
			gradientArray.push({offset:offset, color:this.getColorForIndex(i)});
		}
		gradientArray.push({offset:1, color:this.getColorForIndex(highIndex)});
		return gradientArray;
	}
}
class ViridisPalette extends ColorPaletteModel{
	constructor() {
		super();
		this.palette = [
				[68, 1, 84],
				[71, 16, 90],
				[72, 28, 97],
				[70, 41, 106],
				[65, 53, 115],
				[57, 66, 123],
				[49, 78, 131],
				[42, 91, 140],
				[36, 103, 148],
				[32, 116, 156],
				[30, 128, 164],
				[34, 140, 170],
				[47, 152, 174],
				[68, 164, 175],
				[94, 175, 173],
				[121, 185, 168],
				[149, 194, 160],
				[177, 201, 149],
				[204, 207, 135],
				[229, 211, 120],
				[252, 213, 106],
				[255, 217, 96],
				[255, 221, 92],
				[255, 224, 89],
				[255, 228, 86],
				[255, 231, 86],
				[255, 235, 88],
				[255, 238, 90],
				[255, 242, 92],
				[255, 245, 94],
				[255, 248, 99],
				[255, 251, 104],
				[255, 254, 112],
				[255, 255, 121],
				[255, 255, 130],
				[255, 255, 139],
				[255, 255, 148],
				[255, 255, 157],
				[255, 255, 166],
				[255, 255, 174],
				[255, 255, 183],
				[255, 255, 191],
				[255, 255, 199],
				[255, 255, 207],
				[255, 255, 215],
				[255, 255, 221],
				[255, 255, 228],
				[255, 255, 234],
				[255, 255, 239],
				[255, 255, 244],
				[255, 255, 248],
				[255, 255, 252]
		];
	}
}
</script>

<script>
	//top level functions and control
	let loadedTools = {};
	let loadedFiles = {};

	let irAnalysisController = null;
	let colorPaletteModel = null;
	let thermalImageView = null;
	let toolView = null;
	let analysisView = null;

	const g_AnalysisGraph_FontSize = 14;
	const g_AnalysisGraph_Font = "Arial";
	const g_AnalysisGraph_FontColor = 'black';
	const g_AnalysisGraph_AxisColor = 'black';

	function startup() {
		console.log("Main: startup")
		thermalImageView = new ThermalImageView("id_thermalCanvas");
		toolView = new ToolView("id_toolCanvas");
		colorPaletteModel = new ViridisPalette();
		analysisView = new AnalysisView("id_analysisContainer")
		irAnalysisController = new IrAnalysisController(
				"id_thermalCanvasContainer",
				"id_thermalCanvasSizeContainer");
		irAnalysisController.setActiveColorPaletteModel(colorPaletteModel);
		irAnalysisController.setActiveThermalImageView(thermalImageView);
		irAnalysisController.setActiveToolView(toolView);
		irAnalysisController.setActiveAnalysisView(analysisView);

		const loadedFilesContainer = document.getElementById('id_loadedFiles');
		loadedFilesContainer.ondragover = 
				loadedFilesContainer.ondragenter = function(event) {
		  		event.preventDefault();
				};

		loadedFilesContainer.ondrop = dropFiles;
	}

	function handleFileUpload(files) {
		console.log("loading a file")
		for(let i=0; i<files.length; i++) {
			const irFile = files[i];
			if (!irFile) { 
				console.log("handleFileUpload: No file selected.");
			} else {
				let thermalArrayModel = new ThermalArrayModel();
				thermalArrayModel.parseFile(irFile).then(() => {
					let fileInstance = 
							new FileInstanceController(thermalArrayModel,"id_loadedFiles");
					irAnalysisController.addFileInstance(fileInstance);
				});
			}
		}
	}

	function dropFiles(event) {
	  handleFileUpload(event.dataTransfer.files);
	  event.preventDefault();
	}

	function chooseFiles() {
		const fileInput = document.getElementById('id_fileInput');
		handleFileUpload(fileInput.files)
	}

	function activatePointerTool() {
		irAnalysisController.setActiveToolModel(toolPointer);
	}

	function activateProfileTool() {
		irAnalysisController.setActiveToolModel(toolProfile);
	}

	function newTemperatureData() {

	}
</script>
</head>

<body onload="startup()">
	<div class="page-container">
		<div class="title-container">
			<h1>Thermal Image Analysis</h1>
		</div>

		<div class="app-container" id="id_appContainer">
			<div class="appgraphics-container">
				<div class="thermalcanvas-container" id="id_thermalCanvasContainer">
					<div class="thermalcanvas-size-container" 
							id="id_thermalCanvasSizeContainer">
						<canvas class="thermalcanvas-element thermalCanvas" 
								id="id_thermalCanvas"></canvas>
						<canvas class="thermalcanvas-element toolCanvas" 
								id="id_toolCanvas"></canvas>
					</div>
				</div>
				<div class="analysis-container" id="id_analysisContainer">
				</div>
			</div>

			<div class="rightbar-container">
				<h2>Files</h2>
				<input type="button" id="id_loadButton" value="Choose File" 
						onclick="document.getElementById('id_fileInput').click();"/>
				<input type="file" style="display:none;" id="id_fileInput" 
						name="file" multiple="multiple" onchange="chooseFiles()"/>
				<div id="id_loadedFiles" class="loadedfiles-container">
				</div>

				<h2>Tools</h2>
				<button onclick="activatePointerTool()">Pointer</button>
				<button onclick="activateProfileTool()">Profile</button>
				<button onclick="tool2()">Tool 2</button>
				<button onclick="tool3()">Tool 3</button>
			</div>
		</div>

	</div>

	<template id="id_genericAnalysisTemplate">
		<div class="analysiscanvas-container">
			<canvas class="analysisCanvas" id="id_analysisCanvas"></canvas>
		</div>
		<div class="analysisinfo-container">
			Average:<span class="analysisText" id="id_analysisAvg"></span><br>
			Minimum:<span class="analysisText" id="id_analysisMin"></span><br>
			Maximum:<span class="analysisText" id="id_analysisMax"></span><br>
		</div>
	</template>
	<template id="id_fileInstanceTemplate">
		<div id="id_fileInstance" class="fileinstance-container">
			<img id="id_instanceImage" class="fileinstance-image"></img>
			<div class="fileinstance-controls">
				<input type='text' id="id_instanceName" class="fileinstance-name">
				<div id="id_instanceRename" class="fileinstance-button hover-green">
					📝
				</div>
				<div id="id_instanceDelete" class="fileinstance-button hover-red">
					🗑️
				</div>
				<div id="id_Btn3" class="fileinstance-button hover-red"></div>
			</div>
		</div>
	</template>
</body>
</html>




