<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Thermal Image Analysis</title>
<link rel="stylesheet" href="styles.css">
<style>
	* {
		margin: 0;
		padding: 0;
		box-sizing: border-box;
		}
	body, html {
		font-family: Arial, sans-serif;
		font-size: 16px;
		color: rgba(200,200,200);
		background-color: #555;
		height: 100%;
	}
	.page_container {
		width: 100%;
		height: 100%;
		display: grid;
		grid-template-columns: 80% 20%;
		grid-template-rows: 40px calc(100vh - 40px);
	}
	.apptitle {
		grid-column: 1;
		grid-row: 1;
	}
	.rightbar {
		grid-column: 2;
		grid-row: 1 / 3;

	}
	.appgraphics {
		grid-column: 1;
		grid-row: 2;
	}
	.bgblur {
		backdrop-filter: blur(10px);
	}
	.bgdark {
		background-color: rgba(0,0,0,0.2);
	}
	.bglight {
		background-color: rgba(255,255,255,0.1);
	}
	.bgactive {
		background-color: rgba(255,255,255,0.1);
	}
	.bgpassive {
		background-color: rgba(255,255,255,0.1);
	}
	.flexcol_container {
		display: flex;
		flex-direction: column;
		flex-wrap: nowrap;
		border-radius: 10px;
		gap:10px;
	}
	.flexrow_container {
		display: flex;
		flex-direction: row;
		flex-wrap: nowrap;
		border-radius: 10px;
		gap:10px;
	}
	.flexlist_container {
		display: flex;
		flex-direction: column;
		flex-wrap: nowrap;
		border-radius: 0px;
		overflow-y: scroll;
		gap: 4px;
	}
	.flexele_fixed {
		flex: 0 0 auto;
	}
	.flexele_shrink {
		flex: 0 1 auto;
	}
	.flexele_grow {
		flex: 1 0 auto;
	}
	.flexele_both {
		flex: 1 1 auto;
	}
	.flexlist_item {
		border-radius: 0px;
		width: 100%;
		padding: 4px;
		border: 1px solid rgba(0,0,0,0);
	}
	.flexlist_selected {
		background-color: rgba(49,104,142,1);
	}
	.thermgraphics_size{
		box-sizing: content-box;
		width: auto;
		height: auto;
		position: relative;
	}
	.thermcanvas_element {
		position: absolute;
		top:15px;
		left:15px;
		border: 1px solid black;
	}
	.thermcanvas_element:hover {
		cursor: crosshair;
	}

	.appbtn {
		width:min-content;
		height: min-content;
		padding: 3px;
		color: rgba(200,200,200);
		border: 1px solid white;
		font-size: 16px;
	}
	.appbtn_circle {
		width:min-content;
		height: min-content;
		padding: 8px;
		color: rgba(200,200,200);
		border-radius: 50%;
		font-size: 24px;
	}
	.appbtn:hover {
		background-color: rgba(255,255,255,0.5);
	}
	.appbtn_circle:hover {
		background-color: rgba(255,255,255,0.5);
	}
	.appselect {
		width:min-content;
		height: min-content;
		padding: 3px;
		color:rgba(192,190,190);
		border: 1px solid white;
		font-size: 16px;
	}
	.appinput {
		height:min-content;
		width:min-content;
		padding: 8px;
		color:rgba(192,190,190);
		border: none;
		border-radius: 8px;
		font-size: 16px;
	}

	.analysisinfo-container {
		padding: 10px;
		width: 25%;
		height: 100%;
	}
	.analysiscanvas-container {
		padding: 10px;
		width: 75%;
		height: 100%;
	}
	.analysisCanvas {
		top:0;
		left:0;
		width: 100%;
		height: 100%;
	}
	.hover-red:hover {
		background-color: rgba(95,25,35,0.5);
	}
	.hover-green:hover {
		background-color: rgba(95,150,35,0.5);
	}
	.hover-light:hover {
		background-color: rgba(255,255,255,0.1);
	}

	.availtools-container {
		width: 100%;
		height:30%;
		flex: 1 1 auto;
		display: flex;
		flex-direction: column;
		gap: 8px;
		flex-wrap: nowrap;
		overflow-y: scroll;
		background-color: rgba(0,0,0,0.3);
	}
	.toolinstance-container {
		width: 100%;
		height: min-content;
		flex: 0 0 auto;
		display: flex;
		flex-direction: row;
		flex-wrap: nowrap;
		border: none;
	}
	.toolinstance-name {
		width: auto;
		height: 100%;
		flex: 1 1 auto;
	}
	.toolinstance-button {
		width: min-content;
		height: 100%;
		padding: 4px;
		flex: 0 0 auto;
	}
	.selectadd-container {
		width:100%;
		height: auto;
		flex: 0 1 auto;
		flex-direction: row;
		flex-wrap: nowrap;
	}

	.tools-add {
		width:15%;
		height: min-content;
		padding: 3px;
		flex: 0 0 auto;
		border: 1px solid white;
		background-color: rgba(0,0,0,0.1);
		backdrop-filter: blur(4px);
		color:rgba(192,190,190);
		font-size: 16px;
	}

	.tools-add:hover {
		background-color: rgba(255,255,255,0.1);
	}

</style>

<script>
class EventEmitter {
	constructor() {
		this.events = {};
	}
	addEventListener(event, listener) {
		if (!this.events[event]) {
			this.events[event] = [];
		}
		if (!this.events[event].includes(listener)) {
				this.events[event].push(listener);
		}
	}
  removeEventListener(event, listener) {
    if (!this.events[event]) {
        return; // No such event registered
    }
    this.events[event] = this.events[event].filter(cb => cb !== listener);
  }
	emit(type, event) {
		if (this.events[type]) {
			this.events[type].forEach(listener => {
				listener.call(this, event);
			});
		}
	}
}

class FileInstanceView extends EventEmitter{
	constructor(thermalArray, fileListId) {
		super();
		this.thermalArray=thermalArray;
		this.fileList = document.getElementById(fileListId);
		this.elementDiv = null;
		this.elementImage = null;
		this.elementName = null;
		this.btnRename = null;
		this.btnDelete = null;
		this.rendered = false;
	}
	renderElements() {
		if(!this.rendered){
			const template = document.getElementById("id_fileInstanceTemplate");
			const fileInstanceElement = template.content.cloneNode(true).firstElementChild;
			this.fileList.appendChild(fileInstanceElement)
			this.elementDiv = fileInstanceElement;
			this.elementImage = fileInstanceElement.querySelector("#id_instanceImage");
			this.elementImage.addEventListener('click', this.select);
			this.elementImage.src = this.thermalArray.getThermalPreview();
			this.elementName = fileInstanceElement.querySelector("#id_instanceName");
			this.elementName.value = this.thermalArray.name;
			this.elementName.addEventListener('change', this.rename);
			this.btnDelete = fileInstanceElement.querySelector("#id_instanceDelete");
			this.btnDelete.addEventListener('click', this.delete);
			this.rendered=true;
		}
	}
	removeElements() {
		if(this.rendered) {
			this.elementImage.removeEventListener('click', this.select);
			this.elementName.removeEventListener('change', this.rename);
			this.btnDelete.removeEventListener('click', this.delete);
			this.fileList.removeChild(this.elementDiv);
			this.rendered=false;
		}
	}
	setHighlight(highlight=false) {
		if(highlight) {
			this.elementDiv.classList.add('flexlist_selected');
		} else {
			this.elementDiv.classList.remove('flexlist_selected');
		}
	}
	rename = (event) => {
		this.thermalArray.name=this.elementName.value;
	}
	delete = (event) => {
		this.emit("delete",{instance:this});
	}
	select = (event) => {
		this.emit("select",{instance:this});
	}
}

class ToolInstanceView extends EventEmitter{
	constructor(toolModel, toolListId) {
		super();
		this.toolModel=toolModel;
		this.toolList = document.getElementById(toolListId);
		this.elementDiv = null;
		this.elementName = null;
		this.btnDelete = null;
		this.btnScope = null;
		this.rendered = false;
	}
	renderElements() {
		if(!this.rendered) {
			const template = document.getElementById("id_toolInstanceTemplate");
			const toolInstanceElement = template.content.cloneNode(true).firstElementChild;
			this.toolList.appendChild(toolInstanceElement)
			this.elementDiv = toolInstanceElement;
			this.elementName = toolInstanceElement.querySelector("#id_instanceName");
			this.elementName.value = this.toolModel.name;
			this.elementName.addEventListener('change', this.rename);
			this.btnDelete = toolInstanceElement.querySelector("#id_instanceDelete");
			this.btnDelete.addEventListener('click', this.delete);
			this.btnScope = toolInstanceElement.querySelector("#id_instanceScope");
			this.btnScope.addEventListener('click', this.scope);
			this.btnSelect = toolInstanceElement.querySelector("#id_instanceSave");
			this.btnSelect.addEventListener('click', this.select);
			this.rendered = true;
		}
	}
	removeElements() {
		if(this.rendered){
			this.elementName.removeEventListener('change', this.rename);
			this.btnDelete.removeEventListener('click', this.delete);
			this.btnSelect.removeEventListener('click', this.select);
			this.btnScope.removeEventListener('click', this.scope);
			this.toolList.removeChild(this.elementDiv);
			this.rendered=false;
		}
	}
	changeToolList(toolListId) {
		if(this.rendered) {
			this.removeElements();
		}
		this.toolList = document.getElementById(toolListId);
	}
	setHighlight(highlight=false) {
		if(highlight) {
			this.elementDiv.classList.add('flexlist_selected');
		} else {
			this.elementDiv.classList.remove('flexlist_selected');
		}
	}
	rename = (event) => {
		this.toolModel.name=this.elementName.value;
	}
	delete = (event) =>  {
		this.emit("delete",{instance:this});
	}
	select = (event) =>  {
		this.emit("select",{instance:this});
	}
	scope = (event) =>  {
		this.emit("scope",{instance:this});
	}
}

class IrAnalysisController extends EventEmitter{
	constructor(containerDivId, canvasDivId) {
		super();
		this.containerDiv = document.getElementById(containerDivId);
		this.canvasDiv = document.getElementById(canvasDivId);

		this.fileInstances={};
		this.activeFileKey=null;
		this.toolInstances={};
		this.activeToolKey=null;

		this.activeTool = null;
		this.activeThermalArray = null;
		this.activeColorPalette = null;

		this.thermalImageView = null;
		this.toolView = null;
		this.analysisView = null;
		this.viewsLoaded = false;

		window.addEventListener('resize',this.resizeWindow);
		this.canvasDiv.addEventListener('wheel',this.mouseWheel);
		this.canvasDiv.addEventListener('mouseup',this.mouseUp);
		this.canvasDiv.addEventListener('mousedown',this.mouseDown);
		this.canvasDiv.addEventListener('mousein',this.mouseIn);
		this.canvasDiv.addEventListener('mouseout',this.mouseOut);
		this.canvasDiv.addEventListener('mousemove',this.mouseMove);
		this.canvasDiv.addEventListener('keydown',this.keyboard);
	}

	synchronizeEverything() {
		//Check that views are loaded
		if(this.thermalImageView && this.toolView && this.analysisView) {
			this.viewsLoaded = true;
		} else {
			this.viewsLoaded = false;
		}
		//Set the correct tool model
		if(this.activeFileKey && this.activeToolKey) {
			const toolModel = this.toolInstances[this.activeToolKey].toolModel;
			this.activateToolModel(toolModel);
		} else {
			this.activateToolModel(null);
		}
		//Set the active thermal array
		if(this.activeFileKey) {
			const thermalArray = this.fileInstances[this.activeFileKey].thermalArray;
			this.activateThermalArray(thermalArray);
		} else {
			this.activateThermalArray(null);
		}
		//Sync the tool and thermal array
		if(this.activeTool && this.activeThermalArray) {
			this.activeTool.setArray(this.activeThermalArray.getThermalArray());
		}
		//Sync the correct color palettes
		if(this.activeColorPalette && this.activeThermalArray) {
			this.activeThermalArray.activateColorPalette(this.activeColorPalette);
		}
		if(this.activeColorPalette && this.activeTool) {
				this.activeTool.activateColorPalette(this.activeColorPalette);
		}
		//Recalculate canvas sizes
		this.resizeWindow({});
		//Update each view as required
		this.drawThermalImage({});
		this.drawToolCursor({});
		this.drawToolAnalysis({});
	}
	setThermalImageView(thermalImageView) {
		if(this.thermalImageView) {
			this.thermalImageView.removeEventListener('draw',
					this.drawThermalImage);
		}
		this.thermalImageView=thermalImageView;
		this.thermalImageView.addEventListener('draw',
				this.drawThermalImage);
		this.synchronizeEverything();
	}
	setToolView(toolView) {
		if(this.toolView) {
			this.toolView.removeEventListener('draw',
					this.drawTool);
		}
		this.toolView=toolView;
		this.toolView.addEventListener('draw',
				this.drawTool);
		this.synchronizeEverything();
	}
	setAnalysisView(analysisView) {
		if(this.analysisView) {
			this.analysisView.hide();
			this.toolView.removeEventListener('draw',
					this.drawToolAnalysis);
		}
		this.analysisView=analysisView;
		this.analysisView.display();
		this.analysisView.addEventListener('draw',
				this.drawToolAnalysis);
		this.synchronizeEverything();
	}

	activateColorPalette(colorPaletteModel) {
		if(this.activeColorPalette) {
			this.activeColorPalette.removeEventListener('palettechange',
					this.paletteChange);
		}
		this.activeColorPalette = colorPaletteModel;
		this.activeColorPalette.addEventListener('palettechange',
				this.paletteChange);
	}
	activateToolModel(toolModel) {
		if(this.activeTool) {
			this.activeTool.removeEventListener('draw',
					this.drawTool);
		}
		this.activeTool=toolModel;
		if(this.activeTool) {
			this.activeTool.addEventListener('draw',
					this.drawTool);
		}
	}
	activateThermalArray(thermalArrayModel) {
		if(this.activeThermalArray) {
			this.activeThermalArray.removeEventListener('draw',
					this.drawThermalImage);
		}
		this.activeThermalArray = thermalArrayModel;
		if(this.activeThermalArray) {
			this.activeThermalArray.addEventListener('draw',
					this.drawThermalImage);
		}
	}
	activateFileInstance(fileKey) {
		//Deactive currently selected file instance if there is one
		if(this.activeFileKey) {
			//unlisten and hide all local tools
			const prevToolKeys = this.fileInstances[this.activeFileKey].localToolKeys;
			prevToolKeys.forEach((toolKey) => {
				this.unlistenToolInstanceView(this.toolInstances[toolKey]);
				this.toolInstances[toolKey].removeElements();
			});
			//Remove highlight from file instance
			this.fileInstances[this.activeFileKey].setHighlight(false);
		}
		//Activate the new file instance
		this.activeFileKey = fileKey;
		if(this.activeFileKey) {
			//Listen and render all local tools
			const currentLocalToolKeys = 
					this.fileInstances[this.activeFileKey].localToolKeys;
			currentLocalToolKeys.forEach((toolKey) => {
				this.listenToolInstanceView(this.toolInstances[toolKey]);
				this.toolInstances[toolKey].renderElements();
			});
			//add highlight
			this.fileInstances[this.activeFileKey].setHighlight(true);
			//Change active tool
			this.activateToolInstance(
					this.fileInstances[this.activeFileKey].activeToolKey);
		}
	}
	activateToolInstance(toolKey) {
		if(this.activeFileKey) {
			if(this.activeToolKey) {
				this.toolInstances[this.activeToolKey].setHighlight(false);
			}
			this.activeToolKey=toolKey;
			this.fileInstances[this.activeFileKey].activeToolKey=this.activeToolKey;
			if(this.activeToolKey) {
					this.toolInstances[this.activeToolKey].setHighlight(true);
			}
		}
	}

	addFileInstanceView(fileInstanceView) {
		let fileKey=1;
		while(this.fileInstances[fileKey] !== undefined) {
			fileKey++;
		}
		fileInstanceView.fileKey=fileKey;
		fileInstanceView.localToolKeys=[];
		fileInstanceView.activeToolKey=null;
		this.fileInstances[fileKey]=fileInstanceView;
		this.listenFileInstanceView(fileInstanceView);
		fileInstanceView.renderElements();
	}
	listenFileInstanceView(fileInstanceView) {
		fileInstanceView.addEventListener('select',
				this.selectFileInstanceView);
		fileInstanceView.addEventListener('delete',
				this.deleteFileInstanceView);
	}
	unlistenFileInstanceView(fileInstanceView) {
		fileInstanceView.removeEventListener('select',
				this.selectFileInstanceView);
		fileInstanceView.removeEventListener('delete',
				this.deleteFileInstanceView);
	}
	deleteFileInstanceView = (event) => {
		//Remove the file instance view
		this.unlistenFileInstanceView(event.instance);
		event.instance.removeElements();
		//Remove all the associated instance tools
		let localToolKeys = event.instance.localToolKeys;
		localToolKeys.forEach((toolKey) => {
			this.unlistenToolInstanceView(this.toolInstances[toolKey]);
			delete this.toolInstances[toolKey];
		});
		//Incase this was our active file
		if(this.activeFileKey == event.instance.fileKey) {
			this.activeFileKey = null;
			this.activeToolKey = null;
		}
		delete this.fileInstances[event.instance.fileKey];
		this.synchronizeEverything();
	}
	selectFileInstanceView = (event) =>  {
		//Skip if this is already active instance
		if(this.activeFileKey != event.instance.fileKey) {
			this.activateFileInstance(event.instance.fileKey);
		}
		this.synchronizeEverything();
	}

	addToolInstanceView(toolInstanceView, globalTool=true) {
		//Check if valid to add a local tool currently
		if(!globalTool && !this.activeFileKey) {return;}
		//Add the tool
		let toolKey=1;
		while(this.toolInstances[toolKey] !== undefined) {
			toolKey++;
		}
		toolInstanceView.toolModel.name += `_${toolKey}`
		toolInstanceView.toolKey=toolKey;
		toolInstanceView.globalTool=globalTool;
		this.toolInstances[toolKey]=toolInstanceView;
		if(globalTool) {
			toolInstanceView.changeToolList('id_availGlobalTools');
		} else {
			toolInstanceView.changeToolList('id_availLocalTools');
			this.fileInstances[this.activeFileKey].localToolKeys.push(toolKey);
		}
		this.listenToolInstanceView(toolInstanceView);
		toolInstanceView.renderElements();
	}
	listenToolInstanceView(toolInstanceView) {
		toolInstanceView.addEventListener('select',
				this.selectToolInstanceView);
		toolInstanceView.addEventListener('delete',
				this.deleteToolInstanceView);
		toolInstanceView.addEventListener('scope',
				this.scopeToolInstanceView);
	}
	unlistenToolInstanceView(toolInstanceView) {
		toolInstanceView.removeEventListener('select',
				this.selectToolInstanceView);
		toolInstanceView.removeEventListener('delete',
				this.deleteToolInstanceView);
		toolInstanceView.removeEventListener('scope',
				this.scopeToolInstanceView);
	}
	selectToolInstanceView = (event) =>  {
		if(this.activeToolKey != event.instance.toolKey) {
			this.activateToolInstance(event.instance.toolKey);
		}
		this.synchronizeEverything();
	}
	deleteToolInstanceView = (event) =>  {
		let toolKey = event.instance.toolKey;
		//If deleting the current active tool
		if(this.activeToolKey == toolKey) {
			this.activateToolInstance(null);
		}
		//Remove all references to this tool from file instances
		for(let fileKey in this.fileInstances) {
			//Remove this tool from local tool key list(s)
			this.fileInstances[fileKey].localToolKeys = 
					this.fileInstances[fileKey].localToolKeys.filter(
							localToolKey => localToolKey !== toolKey);
			//Make sure this is not the active tool of any file instance
			if(this.fileInstances[fileKey].activeToolKey == toolKey) {
				this.fileInstances[fileKey].activeToolKey = null;
			}
		}
		//Finish removing the instance
		this.unlistenToolInstanceView(event.instance);
		event.instance.removeElements();
		delete this.toolInstances[toolKey];
		this.synchronizeEverything();
	}
	scopeToolInstanceView = (event) =>  {
		const toolKey = event.instance.toolKey;
		if(event.instance.globalTool) {
			//Can only go from global -> local is there is an active file
			if(this.activeFileKey) {
				//Move the view to correct list
				event.instance.globalTool=false;
				event.instance.removeElements();
				event.instance.changeToolList('id_availLocalTools');
				event.instance.renderElements();
				//Add this tool as a local tool of active file
				this.fileInstances[this.activeFileKey].localToolKeys.push(toolKey);
				//Remove references to this tool from other non-active files
				for(let fileKey in this.fileInstances) {
					if(fileKey != this.activeFileKey 
						&& this.fileInstances[fileKey].activeToolKey == toolKey) {
						this.fileInstances[fileKey].activeToolKey = null;
					}
				}
			}
		} else {
			//Move the view to correct list
			event.instance.globalTool=true;
			event.instance.removeElements();
			event.instance.changeToolList('id_availGlobalTools');
			event.instance.renderElements();
			//Remove from list of local tools
			this.fileInstances[this.activeFileKey].localToolKeys = 
					this.fileInstances[this.activeFileKey].localToolKeys.filter(
							localToolKey => localToolKey !== toolKey);
		}
		//Retain selection of this tool
		if (this.activeToolKey == event.instance.toolKey) {
			this.activateToolInstance(event.instance.toolKey);
		}
	}

	drawThermalImage = (event) =>  {
		if(this.viewsLoaded) {
			if(this.activeThermalArray) {
				let thermalImageGraphics = this.activeThermalArray.getThermalImage();
				thermalImageGraphics = calcGraphicPixelScale(thermalImageGraphics, 
						this.activeThermalArray.arrayWidth(),
						this.activeThermalArray.arrayHeight(),
						this.thermalImageView.canvasWidth(),
						this.thermalImageView.canvasHeight());
				this.thermalImageView.draw(thermalImageGraphics);
			} else {
				this.thermalImageView.draw([{type:'blank'}]);
			}
		}
	}
	drawTool = (event) => {
		this.drawToolCursor(event);
		this.drawToolAnalysis(event);
	}
	drawToolCursor = (event) => {
		if(this.viewsLoaded) {
			if(this.activeTool && this.activeThermalArray) {
				let toolImageGraphics = this.activeTool.getToolGraphics();
				toolImageGraphics = calcGraphicPixelScale(toolImageGraphics, 
						this.activeThermalArray.arrayWidth(),
						this.activeThermalArray.arrayHeight(),
						this.thermalImageView.canvasWidth(),
						this.thermalImageView.canvasHeight());
				this.toolView.draw(toolImageGraphics);
			} else {
				this.toolView.draw([{type:'blank'}]);
			}
		}
	}
	drawToolAnalysis = (event) => {
		if(this.viewsLoaded) {
			if(this.activeTool) {
				let analyticsImageGraphics = this.activeTool.getAnalyticsGraphics();
				this.analysisView.draw(analyticsImageGraphics);
			} else {
				this.analysisView.draw([{type: 'blank'}]);
			}
		}
	}
	paletteChange = (event) => {
		if(this.activeThermalArray) {
			this.activeThermalArray.paletteChange();
		}
	}
	resizeWindow = (event) => {
		let arrayHeight = 50;
		let arrayWidth = 50;
		if(this.activeThermalArray) {
			arrayHeight = this.activeThermalArray.arrayHeight();
			arrayWidth = this.activeThermalArray.arrayWidth();
		}
		const divHeight = this.containerDiv.offsetHeight-40;
		const divWidth = this.containerDiv.offsetWidth-40;
		const canvasSize = calcCanvasSize(arrayWidth, arrayHeight, divWidth, divHeight);
		this.canvasDiv.style.width = (canvasSize.width+30)+'px';
		this.canvasDiv.style.height = (canvasSize.height+30)+'px';
		if(this.thermalImageView) {
			this.thermalImageView.setSize(canvasSize.width, canvasSize.height);
		}
		if(this.toolView) {
			this.toolView.setSize(canvasSize.width, canvasSize.height);
		}
		if(this.analysisView) {
			this.analysisView.resizeUpdate();
		}
	}
	mouseWheel = (event) =>  {
		if(this.activeTool) {
			this.activeTool.mouseWheel(event.deltaX, event.deltaY);
		}
	}
	mouseUp = (event) =>  {
		if(this.activeTool) {
			this.activeTool.mouseUp();
		}
	}
	mouseDown = (event) =>  {
		if(this.activeTool && this.activeThermalArray) {
			let arrayLoc = calcArrayLocfromPixelLoc(
					event.offsetX, event.offsetY,
					this.activeThermalArray.arrayWidth(),
					this.activeThermalArray.arrayHeight(),
					this.thermalImageView.canvasWidth(),
					this.thermalImageView.canvasHeight());
			this.activeTool.mouseDown(arrayLoc.x, arrayLoc.y);
		}
	}
	mouseIn = (event) =>  {
		if(this.activeTool) {
			this.activeTool.mouseIn();
		}
	}
	mouseOut = (event) =>  {
		if(this.activeTool) {
			this.activeTool.mouseOut();
		}
	}
	mouseMove = (event) =>  {
		if(this.activeTool && this.activeThermalArray) {
			let arrayLoc = calcArrayLocfromPixelLoc(
					event.offsetX, event.offsetY,
					this.activeThermalArray.arrayWidth(),
					this.activeThermalArray.arrayHeight(),
					this.thermalImageView.canvasWidth(),
					this.thermalImageView.canvasHeight());
			this.activeTool.mouseMove(arrayLoc.x, arrayLoc.y);
		}
	}
	keyboard = (event) =>  {
		if(this.activeTool) {
			this.activeTool.keyboard();
		}
	}
}

class AnalysisTool extends EventEmitter{
	static name() {return "Analysis Tool";}
	constructor() {
		super();
		this.name="AnalysisTool";
	}
	mouseWheel(deltaX, deltaY) {;}
	mouseUp(mouseX, mouseY) {;}
	mouseDown(mouseX, mouseY) {;}
	mouseIn() {;}
	mouseOut() {;}
	mouseMove(mouseX, mouseY) {;}
	keyboard(key) {;}
	setArray(thermalArray) {;}
	getToolGraphics() {return [];}
	activateColorPalette(colorPaletteModel) {
		this.activeColorPalette=colorPaletteModel;
		this.draw();
	}
	draw() {
		if(this.activeColorPalette && this.thermalArray) {
			this.emit('draw',{});
		}
	}
}
class WindowTool extends AnalysisTool {
	static name() {return "Pointer Tool";}
	constructor() {
		super();
		this.name="WindowTool";
		this.activeColorPalette=null;
		this.boxWidth=3;
		this.boxHeight=3;
		this.mouseX=null;
		this.mouseY=null;
		this.dragging=false;
		this.thermalArray=null;
		this.analytics={};
		this.histNumBins=15;
	}
	mouseWheel(deltaX, deltaY) {
		if(deltaY < 0) {
			this.boxWidth+=1;
			this.boxHeight+=1;
			this.calculateAnalytics();
			this.draw();
		}
		else if(deltaY > 0 && this.boxWidth>3) {
			this.boxWidth-=1;
			this.boxHeight-=1;
			this.calculateAnalytics();
			this.draw();
		}
	}
	mouseUp(mouseX, mouseY) {
		this.dragging=false;
	}
	mouseDown(mouseX, mouseY) {
		this.dragging=true;
	}
	mouseIn() {;}
	mouseOut() {
		this.dragging=false;
	}
	mouseMove(mouseX, mouseY) {
		if(this.dragging && this.thermalArray) {
			if(this.mouseX!=mouseX || this.mouseY!=mouseY)
			{
				this.mouseX=mouseX;
				this.mouseY=mouseY;
				this.calculateAnalytics();
				this.draw();
			}
		}
	}
	setArray(thermalArray) {
		this.thermalArray=thermalArray;
		this.calculateAnalytics();
		this.draw();
	}
	calculateAnalytics() {
		if(this.mouseX===null || this.mouseY===null) {
			this.mouseY=Math.floor(this.thermalArray.length/2);
			this.mouseX=Math.floor(this.thermalArray[0].length/2);
		}
		const x0 = this.mouseX-this.boxWidth;
		const x1 = this.mouseX+this.boxWidth;
		const y0 = this.mouseY-this.boxHeight;
		const y1 = this.mouseY+this.boxHeight;
		let cursorArray = getSubArray(this.thermalArray, x0, x1, y0, y1);
		let minTemp = {
			t: Infinity,
			x: -1,
			y: -1
		};
		let maxTemp = {
			t: -Infinity,
			x: -1,
			y: -1
		};
		let sumTemps=0;
		let numTemps=0;
		for (let i = 0; i < cursorArray.length; i++) {
			for (let j = 0; j < cursorArray[i].length; j++) {
				const value = cursorArray[i][j];
				if (typeof value.t === 'number') {
					sumTemps += value.t;
					numTemps += 1;
					if (value.t < minTemp.t) {
						minTemp.t = value.t;
						minTemp.x = value.x;
						minTemp.y = value.y;
					}
					if (value.t > maxTemp.t) {
						maxTemp.t = value.t;
						maxTemp.x = value.x;
						maxTemp.y = value.y;
					}
				}
			}
		}
		this.analytics.minTemp=minTemp;
		this.analytics.maxTemp=maxTemp;
		this.analytics.avgTemp=sumTemps/numTemps;
		this.analytics.cursorArray=cursorArray;
		this.analytics.boxW=this.boxWidth;
		this.analytics.boxH=this.boxHeight;
		this.analytics.cursorX=this.mouseX;
		this.analytics.cursorY=this.mouseY;
		this.analytics.thermalArray = this.thermalArray;
	}
	getToolGraphics() {
		let toolImageGraphics=[];
		//Inner box
		let centerBox={type:'box', 
				x:this.analytics.cursorX, y:this.analytics.cursorY,
				w:0, h:0, 
				color:'black', stroke:'thin', mode:'inner'};
		let windowBox={type:'box', 
				x:this.analytics.cursorX, y:this.analytics.cursorY,
				w:this.analytics.boxW, h:this.analytics.boxH, 
				color:'black', stroke:'bold', mode:'outer'};
		let minBox={type:'box', 
				x:this.analytics.minTemp.x, y:this.analytics.minTemp.y,
				w:0, h:0, 
				color:'blue', stroke:'normal', mode:'outer'};
		let maxBox={type:'box', 
				x:this.analytics.maxTemp.x, y:this.analytics.maxTemp.y,
				w:0, h:0, 
				color:'red', stroke:'normal', mode:'outer'};
		toolImageGraphics.push(centerBox);
		toolImageGraphics.push(windowBox);
		toolImageGraphics.push(minBox);
		toolImageGraphics.push(maxBox);
		return toolImageGraphics;
	}
	getAnalyticsGraphics() {
		let analyticsGraphics=[];
		//Create histogram information
		//Flatten the 2D array
		let histogramArray=[];
		const tempArray = this.analytics.cursorArray;
		for (let i = 0; i < tempArray.length; i++) {
			for (let j = 0; j < tempArray[i].length; j++) {
				if (typeof tempArray[i][j].t === 'number') {
					histogramArray.push(tempArray[i][j].t)
				}
			}
		}
		// Calculate min and max values
		const histMin = Math.min(...histogramArray);
		const histMax = Math.max(...histogramArray);
		// Calculate bin size
		const binSize = (histMax - histMin) / this.histNumBins;
		// Initialize an array for bin counts
		let histBins = new Array(this.histNumBins).fill(null).map(() =>
				({count:0, color:'black', t0:0, t1:0, h:0}));
		// Populate histBins
		for (let i=0; i<histogramArray.length; i++) {
			const value = histogramArray[i];
			const binIndex = Math.min(
					Math.floor((value - histMin) / binSize), 
					this.histNumBins - 1);
			histBins[binIndex].count++;
		}
		// Add extra data to histbins
		for (let i=0; i<histBins.length; i++) {
			histBins[i].t0 = (i*binSize) + histMin;
			histBins[i].t1 = ((1+i)*binSize) + histMin;
			histBins[i].h = histBins[i].count / histogramArray.length;
			histBins[i].color = 'black';
		}
		//Create the gradient color array
		const gradientArray = this.activeColorPalette.getGradientArray(
				this.analytics.minTemp.t, this.analytics.maxTemp.t);
		//compile the histogram instruction
		analyticsGraphics.push({type:'histogram', 
				histBins:histBins,
				color:{type:'gradient', gradient:gradientArray}});
		//Add scalar text values
		analyticsGraphics.push({type:'analysisInfo',
				min:this.analytics.minTemp.t,
				max:this.analytics.maxTemp.t,
				avg:this.analytics.avgTemp});
		return analyticsGraphics;
	}
}
class ProfileTool extends AnalysisTool {
	static name() {return "Profile Tool";}
	constructor() {
		super();
		this.name="ProfileTool";
		this.width=1;
		this.mouseX = 0;
		this.mouseY = 0;
		this.startX=null;
		this.startY=null;
		this.endX=null;
		this.endY=null;
		this.dragging=false;
		this.thermalArray=null;
		this.analytics={};
		this.histNumBins=10;
	}
	mouseWheel(deltaX, deltaY) {
	}
	mouseUp(mouseX, mouseY) {
		this.dragging=false;
	}
	mouseDown(mouseX, mouseY) {
		this.dragging=true;
		this.startX=mouseX;
		this.startY=mouseY;
	}
	mouseIn() {;}
	mouseOut() {
		this.dragging=false;
	}
	mouseMove(mouseX, mouseY) {
		if(this.thermalArray) {
			if(this.dragging) {
				if(this.endX!=mouseX || this.endY!=mouseY)
				{
					this.endX=mouseX;
					this.endY=mouseY;
					this.calculateAnalytics();
					this.draw();
				}
			}
		}
	}
	setArray(thermalArray) {
		this.thermalArray=thermalArray;
		this.calculateAnalytics();
		this.draw();
	}
	calculateAnalytics() {
		if(this.startX===null || this.startY===null) {
			this.startX=2;
			this.startY=Math.floor(this.thermalArray.length/2);
			this.endX=this.thermalArray[0].length - 3;
			this.endY=this.startY;
		}
		const x0 = this.startX;
		const x1 = this.endX;
		const y0 = this.startY;
		const y1 = this.endY;
		let profileThermalArray = getLineArray(this.thermalArray, x0, x1, y0, y1);
		let minTemp = {
			t: Infinity,
			x: -1,
			y: -1
		};
		let maxTemp = {
			t: -Infinity,
			x: -1,
			y: -1
		};
		let sumTemps=0;
		let numTemps=0;
		for (let i = 0; i < profileThermalArray.length; i++) {
			const value = profileThermalArray[i];
			if (typeof value.t === 'number') {
				sumTemps += value.t;
				numTemps += 1;
				if (value.t < minTemp.t) {
					minTemp.t = value.t;
					minTemp.x = value.x;
					minTemp.y = value.y;
				}
				if (value.t > maxTemp.t) {
					maxTemp.t = value.t;
					maxTemp.x = value.x;
					maxTemp.y = value.y;
				}
			}
		}
		this.analytics.startX=this.startX;
		this.analytics.startY=this.startY;
		this.analytics.minTemp=minTemp;
		this.analytics.maxTemp=maxTemp;
		this.analytics.avgTemp={t:sumTemps/numTemps};
		this.analytics.cursorArray=profileThermalArray;
		this.analytics.thermalArray = this.thermalArray;
	}
	getToolGraphics() {
		let toolImageGraphics=[];
		//highlight pixels along the line that aren't the min/max
		for (let i = 0; i < this.analytics.cursorArray.length; i++) {
			const cursorPoint = this.analytics.cursorArray[i];
			if((cursorPoint.x == this.analytics.minTemp.x &&
					cursorPoint.y == this.analytics.minTemp.y) ||
					(cursorPoint.x == this.analytics.maxTemp.x &&
					cursorPoint.y == this.analytics.maxTemp.y) ||
					(cursorPoint.x == this.analytics.startX &&
					cursorPoint.y == this.analytics.startY)) {
				continue;
			} else {
				toolImageGraphics.push({type:'box', 
					x:cursorPoint.x, y:cursorPoint.y,
					w:0, h:0, 
					color:'black', stroke:'thin', mode:'inner'});
			}
		}
		//add the mintemp highlight
		toolImageGraphics.push({type:'box',
				x:this.analytics.minTemp.x, y:this.analytics.minTemp.y,
				w:0, h:0, 
				color:'blue', stroke:'normal', mode:'outer'});
		//add the maxtemp highlight
		toolImageGraphics.push({type:'box',
				x:this.analytics.maxTemp.x, y:this.analytics.maxTemp.y,
				w:0, h:0, 
				color:'red', stroke:'normal', mode:'outer'});
		//add startpoint highlight
		toolImageGraphics.push({type:'box',
				x:this.analytics.startX, y:this.analytics.startY,
				w:0, h:0, 
				color:'black', stroke:'normal', mode:'outer'});
		return toolImageGraphics;
	}
	getAnalyticsGraphics() {
		let analyticsGraphics=[];
		let profileArray = []
		for(let i=0; i<this.analytics.cursorArray.length; i++) {
			let h = Math.sqrt((this.analytics.startX - this.analytics.cursorArray[i].x)**2 +
					(this.analytics.startY - this.analytics.cursorArray[i].y)**2);
			profileArray.push({h:h, t:this.analytics.cursorArray[i].t});
		}
		profileArray=profileArray.sort((a,b) => a.h - b.h);
		const gradientArray = this.activeColorPalette.getGradientArray(
				this.analytics.minTemp.t, this.analytics.maxTemp.t);
		//compile the histogram instruction
		analyticsGraphics.push(
				{type:'profile', 
				profileArray:profileArray,
				color:{type:'gradient', gradient:gradientArray}});
		analyticsGraphics.push({type:'analysisInfo',
				min:this.analytics.minTemp.t,
				max:this.analytics.maxTemp.t,
				avg:this.analytics.avgTemp.t});
		return analyticsGraphics;
	}
}

class CanvasGraphicsView extends EventEmitter{
	constructor(canvasId) {
		super();
		this.canvas = document.getElementById(canvasId);
	}
	canvasWidth() {
		return this.canvas.width;
	}
	canvasHeight() {
		return this.canvas.height;
	}
	setSize(canvasWidth, canvasHeight) {
		if(this.canvas.width!=canvasWidth ||
				this.canvas.height!=canvasHeight) {
			this.canvas.width = canvasWidth;
			this.canvas.height = canvasHeight;
			this.emit('draw',{});
		}
	}
	drawBox(instruction) {
		const boxX = instruction.x;
		const boxY = instruction.y;
		const boxW = instruction.w;
		const boxH = instruction.h;
		let boxStroke = 1;
		switch(instruction.stroke) {
			case 'bold':
				boxStroke=3;
				break;
			case 'thin':
				boxStroke=1;
				break;
			case 'normal':
				boxStroke=2;
				break;
		}
		const boxColor = instruction.color;
		const pixelScaleX = instruction.pixelScale.x;
		const pixelScaleY = instruction.pixelScale.y;
		const canvasCtx = this.canvas.getContext('2d');

		canvasCtx.strokeStyle=boxColor;
		canvasCtx.lineWidth=boxStroke;
		switch(instruction.mode) {
			case 'inner':
				canvasCtx.strokeRect(
				((boxX-boxW)*pixelScaleX), 
				((boxY-boxH)*pixelScaleY), 
				(((2*boxW)+1)*pixelScaleX), 
				(((2*boxH)+1)*pixelScaleY));
				break;

			case 'outer':
				canvasCtx.strokeRect(
				((boxX-boxW)*pixelScaleX)-Math.floor(boxStroke/2), 
				((boxY-boxH)*pixelScaleY)-Math.floor(boxStroke/2), 
				(((2*boxW)+1)*pixelScaleX)+boxStroke, 
				(((2*boxH)+1)*pixelScaleY)+boxStroke);
				break;
		}
	}
	drawPixelArray(instruction) {
		const pixelArray = instruction.pixelArray;
		const pixelScaleX = instruction.pixelScale.x;
		const pixelScaleY = instruction.pixelScale.y;
		const arrayHeight = pixelArray.length;
		const arrayWidth = pixelArray[0].length;
		const canvasCtx = this.canvas.getContext('2d');

		//Render each element of the array as a rectangle
		//Rectangle has sides according to widthpixelscale / heightpixelscale
		for (let y = 0; y < arrayHeight; y++) {
			for (let x = 0; x < arrayWidth; x++) {
				const pixelColor = pixelArray[y][x];
				canvasCtx.fillStyle = pixelColor;
				canvasCtx.fillRect(
						x*pixelScaleX, 
						y*pixelScaleY, 
						pixelScaleX, 
						pixelScaleY);
			}
		}
	}
	draw(drawInstructions) {
		this.clear();
		for (let instruction of drawInstructions) {
			switch(instruction.type) {
				case 'pixelarray':
					this.drawPixelArray(instruction);
					break;
				case 'box':
					this.drawBox(instruction);
					break;
				case 'blank':
					this.clear();
					break;
			}
		}
	}
	clear() {
		const canvasCtx = this.canvas.getContext('2d');
		canvasCtx.clearRect(0,0,this.canvas.width, this.canvas.height);
		//canvasCtx.fillStyle = 'rgba(0,0,0,0.2)';
		//canvasCtx.fillRect(0,0,this.canvas.width, this.canvas.height);
	}
}
class ThermalImageView extends CanvasGraphicsView {
}
class ToolView extends CanvasGraphicsView {
}

class AnalysisView extends EventEmitter{
	constructor(divId) {
		super();
		this.div = document.getElementById(divId);
		this.template = document.getElementById("id_genericAnalysisTemplate");
		this.drawCanvas = document.createElement('canvas');
		this.colorCanvas = document.createElement('canvas');
		this.gap = 2;
	}
	display() {
		this.div.innerHTML = this.template.innerHTML;
		this.canvas = document.getElementById("id_analysisCanvas");
		this.drawCanvas.width = this.canvas.width;
		this.drawCanvas.height = this.canvas.height;
		this.colorCanvas.width = this.canvas.width;
		this.colorCanvas.height = this.canvas.height;
		this.minSpan = document.getElementById("id_analysisMin");
		this.maxSpan = document.getElementById("id_analysisMax");
		this.avgSpan = document.getElementById("id_analysisAvg");
	}
	hide() {
		this.div.innerHTML = "";
	}
	divWidth() {
		return this.div.offsetWidth;
	}
	divHeight() {
		return this.div.offsetHeight;
	}
	resizeUpdate() {
		this.canvas.width = this.canvas.parentElement.clientWidth;
		this.canvas.height = this.canvas.parentElement.clientHeight;
		this.drawCanvas.width = this.canvas.width;
		this.drawCanvas.height = this.canvas.height;
		this.colorCanvas.width = this.canvas.width;
		this.colorCanvas.height = this.canvas.height;
		this.emit('draw',{});
	}
	numberToFixedWidthString(number, mode="round") {
		const absNumber = Math.abs(number);
		let numStr = "";
		let numFloat = 0.0;
		let roundFn = null;
		switch(mode) {
		case "up":
			roundFn = Math.ceil;
			break;
		case "round":
			roundFn = Math.round;
			break;
		case "down":
			roundFn = Math.floor;
			break;
		}
		if(absNumber < 10) {
			numFloat = roundFn(number*1000)/1000;
			numStr = numFloat.toFixed(3);
			
		} else if(absNumber < 100) {
			numFloat = roundFn(number*100)/100;
			numStr = numFloat.toFixed(2);
			
		} else if(absNumber < 1000 ) {
			numFloat = roundFn(number*10)/10
			numStr = numFloat.toFixed(1);
			
		} else if(absNumber < 10000) {
			numFloat = roundFn(number/100)*10000;
			numStr = (numFloat/1000).toFixed(2)+"K";
			
		} else {
			numFloat = roundFn(number/100000)*10000000;
			numStr = (numFloat/1000000).toFixed(2)+"M";
		}
		return {label:numStr, float:numFloat};
	}
	createGraphAxis(xMin, xMax, yMin, yMax, 
			xTicks=0, xGridlines=0, yTicks=0, yGridlines=0) {
		const canvasHeight = this.canvas.height;
		const canvasWidth = this.canvas.width;
		const canvasCtx = this.canvas.getContext('2d');
		canvasCtx.font = 
				`${g_AnalysisGraph_FontSize}px ${g_AnalysisGraph_Font} sans-serif`;
		const labelChars = canvasCtx.measureText("-0.000");
		const labelWidth = labelChars.width + this.gap;
		const labelHeight = g_AnalysisGraph_FontSize + this.gap;
		//Determine dimensions of X axis
		const x0 = labelWidth;
		const xSections = (xTicks+1)*(xGridlines+1);
		const xLen = 
				Math.floor(((canvasWidth-this.gap)-x0)/xSections)
				* xSections;
		const x1 = x0 + xLen;
		const xTickLen = xLen / (xTicks+1);
		const xTickSize = (xMax - xMin) / (xTicks+1);
		const xGridLen = xLen / (xGridlines+1);
		const xGridSize = (xMax - xMin) / (xGridlines+1);
		//Determine dimensions of Y axis
		const y0 = canvasHeight-labelHeight;
		const ySections = (yTicks+1)*(yGridlines+1);
		const yLen = 
				Math.floor((y0-this.gap)/ySections)
				* ySections;
		const y1 = this.gap;
		const yTickLen = yLen / (yTicks+1);
		const yTickSize = (yMax - yMin) / (yTicks+1);
		const yGridLen = yLen / (yGridlines+1);
		const yGridSize = (yMax - yMin) / (yGridlines+1);
		//Draw graph bounding box
		canvasCtx.strokeStyle=g_AnalysisGraph_AxisColor;
		canvasCtx.beginPath();
		canvasCtx.moveTo(x0, y0);
		canvasCtx.lineTo(x0, y1);
		canvasCtx.lineTo(x1, y1);
		canvasCtx.lineTo(x1, y0);
		canvasCtx.lineTo(x0, y0);
		canvasCtx.stroke();
		//Add min and max labels to X and Y axis
		canvasCtx.fillStyle=g_AnalysisGraph_FontColor;
		const xMinLabel = this.numberToFixedWidthString(xMin);
		canvasCtx.fillText(xMinLabel.label,x0,canvasHeight);
		const xMaxLabel = this.numberToFixedWidthString(xMax);
		canvasCtx.fillText(xMaxLabel.label,x1-labelWidth,canvasHeight);
		const yMinLabel = this.numberToFixedWidthString(yMin);
		canvasCtx.fillText(yMinLabel.label,0,y0);
		const yMaxLabel = this.numberToFixedWidthString(yMax);
		canvasCtx.fillText(yMaxLabel.label,0,y1+labelHeight);
		//Draw the x ticks/labels
		for(let i=1; i<xTicks+1; i++) {
			const tickLoc = (i*xTickLen)+x0;
			const tickLabel = this.numberToFixedWidthString((xTickSize*i)+xMin);
			canvasCtx.fillText(tickLabel.label,tickLoc,canvasHeight);
		}
		//Draw the y ticks/labels
		for(let i=1; i<yTicks+1; i++) {
			const tickLoc = y0 - (i*yTickLen);
			const tickLabel = this.numberToFixedWidthString((yTickSize*i)+yMin);
			canvasCtx.fillText(tickLabel.label,0,tickLoc);
		}
		//Draw the x gridlines (vertical gridlines)
		canvasCtx.strokeStyle=g_AnalysisGraph_AxisColor;
		canvasCtx.beginPath();
		for(let i=1; i<xGridlines+1; i++) {
			const gridLoc = (i*xGridLen)+x0;
			canvasCtx.moveTo(gridLoc, y0);
			canvasCtx.lineTo(gridLoc, y1);
		}
		canvasCtx.stroke();
		//Draw the y gridlines (horizontal gridlines)
		canvasCtx.beginPath();
		for(let i=1; i<yGridlines+1; i++) {
			const gridLoc = y0-(i*yGridLen);
			canvasCtx.moveTo(x0, gridLoc);
			canvasCtx.lineTo(x1, gridLoc);
		}
		canvasCtx.stroke();
		return {x0:x0, x1:x1, y0:y0, y1:y1};
	}
	drawHistogram(instruction) {
		const canvasHeight = this.canvas.height;
		const canvasWidth = this.canvas.width;
		const canvasCtx = this.canvas.getContext('2d');
		const drawCtx = this.drawCanvas.getContext('2d');
		const colorCtx = this.colorCanvas.getContext('2d');
		// Clear canvas
		this.clear();
		//Sort the hist bins from low to high bin limit
		const histBins = instruction.histBins.sort((a,b)=>{return a.t0-b.t0;});
		//Find min/max bin temperatures and heights
		let maxT1 = -Infinity;
		let minT0 = Infinity;
		let maxH = -Infinity;
		let minH = 0.0;
		for(let i=0; i<histBins.length; i++) {
			if(histBins[i].t1 > maxT1) {
				maxT1 = histBins[i].t1;
			}
			if(histBins[i].t0 < minT0) {
				minT0 = histBins[i].t0;
			}
			if(histBins[i].h > maxH) {
				maxH = histBins[i].h;
			}
		}
		maxH = Math.ceil(maxH / 0.2)*0.2;
		//Create axis
		const numBins = histBins.length;
		const graph = this.createGraphAxis(minT0,maxT1,minH,maxH,
				numBins-1,0,2,2);
		//Draw the histogram
		const binWidth = Math.floor((graph.x1-graph.x0)/numBins);
		const binYScale = Math.floor((graph.y0-graph.y1)/maxH);
		//Prepare to draw the graph
		drawCtx.fillStyle='black';
		drawCtx.strokeStyle='black';
		//Configre the color canvas
		if(instruction.color.type=='solid') {
			colorCtx.fillStyle=instruction.color.color;
		} 
		else if(instruction.color.type=='gradient') {
			let gradient = 
					colorCtx.createLinearGradient(graph.x0, 0, 
					graph.x1, 0);
			for(let i=0; i<instruction.color.gradient.length; i++) {
				gradient.addColorStop(instruction.color.gradient[i].offset,
						instruction.color.gradient[i].color);
			}
			colorCtx.fillStyle=gradient;
		} 
		else {
			colorCtx.fillStyle='black';
		}
		colorCtx.fillRect(0,0,canvasWidth,canvasHeight);
		//Draw the histrogram
		for(let i=0; i<histBins.length; i++) {
			const binX0 = Math.floor(graph.x0+(binWidth*i))+1;
			const binY0 = graph.y0;
			const binHeight = Math.floor(histBins[i].h*binYScale);
			//canvasCtx.fillStyle = histBins[i].color;
			//draw the bin with 2-pixel gap between bins
			drawCtx.fillRect(binX0, binY0-binHeight, binWidth-2, binHeight);
		}
		//copy drawing over to viewable canvas
		colorCtx.globalCompositeOperation = 'destination-in';
		colorCtx.drawImage(this.drawCanvas,0,0);
		colorCtx.globalCompositeOperation = 'source-over';
		canvasCtx.drawImage(this.colorCanvas,0,0);
	}
	drawProfile(instruction) {
		const canvasHeight = this.canvas.height;
		const canvasWidth = this.canvas.width;
		const canvasCtx = this.canvas.getContext('2d');
		const drawCtx = this.drawCanvas.getContext('2d');
		const colorCtx = this.colorCanvas.getContext('2d');
		// Clear canvas
		this.clear();
		//Get relevant values from instruction
		const profileArray = instruction.profileArray;
		//Determine the min and max temperatures
		let maxTemp = -Infinity;
		let minTemp = Infinity;
		let maxH = -Infinity;
		let minH = Infinity;
		for(let i=0; i<profileArray.length; i++) {
			if(profileArray[i].t > maxTemp) {
				maxTemp = profileArray[i].t;
			}
			if(profileArray[i].t < minTemp) {
				minTemp = profileArray[i].t;
			}
			if(profileArray[i].h > maxH) {
				maxH = profileArray[i].h;
			}
			if(profileArray[i].h < minH) {
				minH = profileArray[i].h;
			}
		}
		//Create axis
		const graph = this.createGraphAxis(minH,maxH,minTemp,maxTemp,
				0,0,2,5);
		const xScale = (graph.x1-graph.x0)/(maxH-minH);
		const yScale = (graph.y0-graph.y1)/(maxTemp-minTemp);
		//Prepare to draw profile
		drawCtx.fillStyle='black';
		drawCtx.strokeStyle='black';
		drawCtx.lineWidth=2;
		//Setup color canvas
		if(instruction.color.type=='solid') {
			colorCtx.fillStyle=instruction.color.color;
		} 
		else if(instruction.color.type=='gradient') {
			let gradient = 
					colorCtx.createLinearGradient(0, graph.y0, 
					0, graph.y1);
			for(let i=0; i<instruction.color.gradient.length; i++) {
				gradient.addColorStop(instruction.color.gradient[i].offset,
						instruction.color.gradient[i].color);
			}
			colorCtx.fillStyle=gradient;
		} 
		else {
			colorCtx.fillStyle='black';
		}
		colorCtx.fillRect(0,0,canvasWidth,canvasHeight);
		//Draw the profile line
		drawCtx.beginPath();
		drawCtx.moveTo(
				(graph.x0+(xScale*(profileArray[0].h-minH))), 
				(graph.y0-(yScale*(profileArray[0].t-minTemp)))
				);
		for(let i=1; i<profileArray.length-1; i++) {
			drawCtx.lineTo(
					(graph.x0+(xScale*(profileArray[i].h-minH))), 
					(graph.y0-(yScale*(profileArray[i].t-minTemp)))
					);
		}
		drawCtx.stroke();
		//copy drawing over to viewable canvas
		colorCtx.globalCompositeOperation = 'destination-in';
		colorCtx.drawImage(this.drawCanvas,0,0);
		colorCtx.globalCompositeOperation = 'source-over';
		canvasCtx.drawImage(this.colorCanvas,0,0);
	}
	drawAnalysisInfo(instruction) {
		this.minSpan.innerHTML = instruction.min;
		this.maxSpan.innerHTML = instruction.max;
		this.avgSpan.innerHTML = instruction.avg;
	}
	draw(drawInstructions) {
		for (let instruction of drawInstructions) {
			switch(instruction.type) {
				case 'histogram':
					this.drawHistogram(instruction);
					break;
				case 'profile':
					this.drawProfile(instruction);
					break;
				case 'analysisInfo':
					this.drawAnalysisInfo(instruction);
					break;
				case 'blank':
					this.clear();
					break;
			}
		}
	}
	clear() {
		const canvasHeight = this.canvas.height;
		const canvasWidth = this.canvas.width;
		const canvasCtx = this.canvas.getContext('2d');
		const drawCtx = this.drawCanvas.getContext('2d');
		const colorCtx = this.colorCanvas.getContext('2d');
		canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);
		colorCtx.clearRect(0,0,canvasWidth,canvasHeight);
		drawCtx.clearRect(0,0,canvasWidth,canvasHeight);
		//canvasCtx.fillStyle = 'rgba(0,0,0,0.2)';
		//canvasCtx.fillRect(0,0,this.canvas.width, this.canvas.height);
		this.minSpan.innerHTML = "";
		this.maxSpan.innerHTML = "";
		this.avgSpan.innerHTML = "";
	}
}

class ThermalArrayModel extends EventEmitter{
	constructor() {
		super();
		console.log("ThermalArrayModel: make array model");
		this.name="";
		this.thermalArray=[];
		this.thermalFileModel = new ThermalFileModel();
		this.activeColorPalette = null;
	}
	arrayWidth() {
		return this.thermalArray[0].length;
	}
	arrayHeight() {
		return this.thermalArray.length;
	}
	getThermalArray() {
		return this.thermalArray;
	}
	getThermalImage() {
		let thermalImageArray = [];
		//Find min and max values of temperature array
		if(this.thermalArray) {
			this.activeColorPalette.initializePalette(this.thermalArray);
			for (let row of this.thermalArray) {
				let thermalRow =[]
				for (let value of row) {
					if (!isNaN(value)) {
						thermalRow.push(
								this.activeColorPalette.getColorForValue(value));
					} else {
						thermalRow.push(this.activeColorPalette.nullColor());
					}
				}
				thermalImageArray.push(thermalRow);
			}
		}
		let graphicsInstructions = [{type:'pixelarray',
				pixelArray:thermalImageArray}];
		return graphicsInstructions;
	}
	getThermalPreview() {
		return this.thermalFileModel.dataUrl;
	}
	parseFile(irFile) {
		return new Promise((resolve, reject) => {
			this.thermalFileModel.loadFile(irFile).then(() => {
				this.createThermalArray();
				this.name=this.thermalFileModel.fileName;
				resolve();
			}).catch((error) => {
				reject(new Error(error));
			});
		});
	}
	activateColorPalette(colorPaletteModel) {
		this.activeColorPalette=colorPaletteModel;
		this.emit('draw',{});
	}
	createThermalArray() {
		const rawData=this.thermalFileModel.dataFLIR.rawData;
		const cameraData=this.thermalFileModel.dataFLIR.cameraData;
		if(!rawData || !cameraData) {
			throw "Did not find raw camera data";
		}
		this.thermalArray=[];
		if(rawData['ThermalImage'].length < 
				(rawData['ImageHeight'] * rawData['ImageWidth'])) {
			throw "ThermalImage has wrong length (not Height * Width)";
		}
		this.arrayRendered=false;
		const e = Math.E;
			const R1 = cameraData[ 'PlanckR1'];
			const R2 = cameraData[ 'PlanckR2'];
			const B = cameraData[ 'PlanckB'];
			const F = cameraData[ 'PlanckF'];
			const O = cameraData[ 'PlanckO'];
			const T_refl = cameraData[ 'ReflectedApparentTemperature'];
			const Emissivity = cameraData[ 'Emissivity'];

		for (let h=0; h<rawData['ImageHeight']; h++) {
			let row=[];
			let rowOffset = h*rawData['ImageWidth'];
			for (let w=0; w<rawData['ImageWidth']; w++) {
					const S = rawData['ThermalImage'][rowOffset+w];
					const RAW_refl = R1 / (R2 * (Math.pow(e, B/T_refl) - F)) - O;
					const RAW_obj = (S - (1 - Emissivity) * RAW_refl) / Emissivity;
					const T_obj = B / Math.log(R1 / (R2 * (RAW_obj + O)) + F);
					row.push(T_obj);
			}
			this.thermalArray.push(row)
		}
		this.emit('draw',{});
	}
}

class ThermalFileModel extends EventEmitter{
	constructor() {
		super();
		this.byteArray=null;
		this.dataUrl=null;
		this.fileName="";
		this.segmentList=[];
		this.bytesFLIR=[];
		this.headerFLIR={};
		this.recordsFLIR={};
		this.dataFLIR={};
	}
	loadFile(irFile) {
		return new Promise((resolve, reject) => {
			let byteArrayReader = new FileReader();
			byteArrayReader.onloadend = () => {
				if (byteArrayReader.result) {
					this.byteArray = new Uint8Array(byteArrayReader.result);
					this.parseFile();
					let dataUrlReader = new FileReader();

					dataUrlReader.onloadend = () => {
						if (dataUrlReader.result) {
							this.dataUrl = dataUrlReader.result;
							this.fileName = irFile.name;
							resolve();
						}
					};
					dataUrlReader.onerror = (error) => {
						reject(new Error(error));
					}
					dataUrlReader.readAsDataURL(irFile);
				}
			};
			byteArrayReader.onerror = (error) => {
				reject(new Error(error));
			}
			byteArrayReader.readAsArrayBuffer(irFile);
		});
	}
	parseFile() {
		console.log("ThermalFileModel: find segments");
		this.findSegments();
		console.log("ThermalFileModel: extract FLIR segments");
		this.extractFLIRSegments();
		console.log("ThermalFileModel: process FLIR header");
		this.processFLIRHeader();
		console.log("ThermalFileModel: process FLIR records");
		this.processFLIRRecords();
		console.log("ThermalFileModel: process Raw Data");
		this.processRawData();
		console.log("ThermalFileModel: process Camera Data");
		this.processCameraData();
	}
	findSegments() {
		let i = 0;
		let found_exif = false;
		this.segmentList=[];
		//check that it's a valid jpeg (starts with 0xD8FF)
		if (this.byteArray[i] !== 0xFF || this.byteArray[i + 1] !== 0xD8) {
			throw "Not a valid JPEG file";
		}
		i += 2;
		//create list of all jpeg segments 
		//	(segments starts with 0xFFyy where yy isn't 0x00)
		//the list is like [[segment id, segment start index,segment length]]
		while (i < this.byteArray.length) {
			if(this.byteArray[i] == 0xFF){
				if(this.byteArray[i+1] != 0x00){
					let segment_info=[];
					let segment_id = this.byteArray[i + 1];
					if(segment_id==225) {
						found_exif=true;
					}
					let segment_start = i+2;
					let segment_length = 0;
					segment_info.push(segment_id);
					segment_info.push(segment_start)
					segment_length = (this.byteArray[segment_start] << 8) + 
							this.byteArray[segment_start+1];
					if(this.byteArray[segment_start+segment_length]==0xFF && 
							this.byteArray[segment_start+segment_length+1]!=0x00) {
						segment_info.push(segment_length);
						i = segment_start+segment_length;
					} else {
						segment_info.push(0);
						i+=2;
					}
					this.segmentList.push(segment_info);
				} else{i+=2;}
			} else{i+=1;}
		}
		if(!this.segmentList) {throw "Found no segments"}
		if(!found_exif) {throw "Found no EXIF segments"}
	}
	extractFLIRSegments() {
		//compile segments into flir data
		this.bytesFLIR = new Uint8Array([]);
		for(const segment_info of this.segmentList) {
			if(segment_info[0]==225 && segment_info[2]>=0x40) //check if exif segment and large enough for data
			{	
				//prepare to slice up start of segment for identification
				let segment_size_start=segment_info[1];
				let segment_type_start=segment_size_start+2;
				let segment_contents_start=segment_type_start+8; //flir records have 8 bytes of id at beginning
				let segment_size_bytes=segment_info[2];
				let segment_contents_size=segment_size_bytes-(2+8); //excluding 2 byte segment size and 8 byte id
				//Slice up array and determine if FLIR type
				let segment_type_bytes = this.byteArray.slice(segment_type_start, segment_type_start+6);
				let segment_type=""
				for(let i=0; i<6; i++){
					segment_type+=String.fromCharCode(segment_type_bytes[i]);
				}
				//Check that the segment tag is correct
				if(segment_type.startsWith("FLIR")){
					//combine this segment with previous flir segments
					let segment_contents_bytes=this.byteArray.slice(segment_contents_start, segment_contents_start+segment_contents_size);
					this.bytesFLIR = concatenateUint8Arrays(this.bytesFLIR, segment_contents_bytes);
				}
			}
		}
		if(!this.bytesFLIR) {
			throw "Found no FLIR segments"
		}
	}
	processFLIRHeader() 
	{
		if(this.bytesFLIR.length<0x40) {
			throw "FLIR segment is too small"
		}
		let header_bytes=this.bytesFLIR.slice(0, 0x40);
		if(String.fromCharCode(header_bytes[0])=="F" || 
				String.fromCharCode(header_bytes[0])=="A")
		{
			if(String.fromCharCode(header_bytes[1])=="F" 
				&& String.fromCharCode(header_bytes[2])=="F"
				&& header_bytes[3]==0)
			{
				this.headerFLIR={};
				this.headerFLIR['Creator']=getstring(header_bytes,0x04,16);
				this.headerFLIR['Version']=get32u(header_bytes,0x14);
				this.headerFLIR['RecordOffset']=get32u(header_bytes,0x18);
				this.headerFLIR['NumRecords']=get32u(header_bytes,0x1c);
				this.headerFLIR['NextIndex']=get32u(header_bytes,0x20);
				this.headerFLIR['SwapPattern']=get16u(header_bytes,0x24);
				this.headerFLIR['Spares']=get16u_array(header_bytes,0x28, 7);
				this.headerFLIR['Reserved']=get32u_array(header_bytes,0x34, 2);
				this.headerFLIR['Checksum']=get32u(header_bytes,0x3c);
				return;
			}
		}
		throw "FLIR header has invalid start code"
	}
	processFLIRRecords()
	{
		if(this.headerFLIR['NumRecords']>255) {
			throw "Number of records is invalid";
		}
		let records_start_index = this.headerFLIR['RecordOffset'];
		let records_end_index = records_start_index+
				(0x20 * this.headerFLIR['NumRecords']);
		if(records_end_index > this.bytesFLIR.length) {
			throw "FLIR records extend past end of records";
		}
		//Extract the record header sections
		this.bytesRecords=this.bytesFLIR.slice(records_start_index, records_end_index);
		//Extract information for each record
		this.recordsFLIR={}
		for(let i=0; i<this.headerFLIR['NumRecords']; ++i)
		{
			let record={}
			let record_start=i*0x20;
			record['Type']=get16u(this.bytesRecords,record_start+0x00);
			record['SubType']=get16u(this.bytesRecords,record_start+0x02);
			record['Version']=get32u(this.bytesRecords,record_start+0x04);
			record['IndexID']=get32u(this.bytesRecords,record_start+0x08);
			record['RecordOffset']=get32u(this.bytesRecords,record_start+0x0c);
			record['RecordLength']=get32u(this.bytesRecords,record_start+0x10);
			record['Parent']=get32u(this.bytesRecords,record_start+0x14);
			record['ObjectNumber']=get32u(this.bytesRecords,record_start+0x18);
			record['Checksum']=get32u(this.bytesRecords,record_start+0x1c);
			if(record['Type']==0) {
				continue;
			}
			else {
				this.recordsFLIR[record['Type']]=record;
			}
		}
	}
	processRawData()
	{
		if(!this.recordsFLIR.hasOwnProperty(0x01)) {
			throw "FLIR records missing key for raw data";
		}
		let reverse=false;
		let record=this.recordsFLIR[0x01];
		this.dataFLIR["rawData"]={};
		let raw_data={};
		raw_data['ByteOrder'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x00);
		if(raw_data['ByteOrder']>0x0100) {
			reverse=true;
		}
		raw_data['ByteOrder'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x00, reverse);
		raw_data['ImageWidth'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x02, reverse);
		raw_data['ImageHeight'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x04, reverse);
		raw_data['ThermalImage'] = 
		get16u_array(this.bytesFLIR, record['RecordOffset']+0x1E+2, 
				raw_data['ImageWidth']*raw_data['ImageHeight'], reverse)
		this.dataFLIR["rawData"] = raw_data;
	}
	processCameraData()
	{
		if(!this.recordsFLIR.hasOwnProperty(0x20)) {
			throw "FLIR records missing key for camera data";
		}
		let reverse=false;
		let record=this.recordsFLIR[0x20];
		this.dataFLIR["cameraData"]={};
		let camera_data={};
		camera_data['ByteOrder'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x00);
		if(camera_data['ByteOrder']>0x0100) {
			reverse=true;
		}
		camera_data[ 'ByteOrder'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x00, reverse);
		camera_data[ 'Emissivity'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x20, reverse);
		camera_data[ 'ObjectDistance'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x24, reverse);
		camera_data[ 'ReflectedApparentTemperature'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x28, reverse);
		camera_data[ 'AtmosphericTemperature'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x2c, reverse);
		camera_data[ 'IRWindowTemperature'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x30, reverse);
		camera_data[ 'IRWindowTransmission'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x34, reverse);
		camera_data[ 'RelativeHumidity'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x3c, reverse);
		camera_data[ 'PlanckR1'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x58, reverse);
		camera_data[ 'PlanckB'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x5c, reverse);
		camera_data[ 'PlanckF'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x60, reverse);
		camera_data[ 'AtmosphericTransAlpha1'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x070, reverse);
		camera_data[ 'AtmosphericTransAlpha2'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x074, reverse);
		camera_data[ 'AtmosphericTransBeta1'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x078, reverse);
		camera_data[ 'AtmosphericTransBeta2'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x07c, reverse);
		camera_data[ 'AtmosphericTransX'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x080, reverse);
		camera_data[ 'CameraTemperatureRangeMax'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x90, reverse);
		camera_data[ 'CameraTemperatureRangeMin'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x94, reverse);   
		camera_data[ 'CameraTemperatureMaxClip'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x98, reverse);  
		camera_data[ 'CameraTemperatureMinClip'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x9c, reverse);
		camera_data[ 'CameraTemperatureMaxWarn'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0xa0, reverse);
		camera_data[ 'CameraTemperatureMinWarn'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0xa4, reverse);
		camera_data[ 'CameraTemperatureMaxSaturated'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0xa8, reverse);
		camera_data[ 'CameraTemperatureMinSaturated'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0xac, reverse);  
		camera_data[ 'CameraModel'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0xd4, 32);
		camera_data[ 'CameraPartNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0xf4, 16, reverse);
		camera_data[ 'CameraSerialNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x104, 16, reverse);
		camera_data[ 'CameraSoftware'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x114, 16, reverse);
		camera_data[ 'LensModel'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x170, 32, reverse);
		camera_data[ 'LensPartNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x190, 16, reverse);
		camera_data[ 'LensSerialNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x1a0, 16, reverse);
		camera_data[ 'FieldOfView'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x1b4, reverse);
		camera_data[ 'FilterModel'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x1ec, 16, reverse);
		camera_data[ 'FilterPartNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x1fc, 32, reverse);
		camera_data[ 'FilterSerialNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x21c, 32, reverse);
		camera_data[ 'PlanckO'] = 
		get32s(this.bytesFLIR, record['RecordOffset']+0x308, reverse);
		camera_data[ 'PlanckR2'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x30c, reverse);
		camera_data[ 'RawValueRangeMin'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x310, reverse);
		this.dataFLIR["cameraData"] = camera_data;
	}
}

function getSubArray(array, x0, x1, y0, y1) {
	//Returns an subarray from Array from x0,y0 to x1,y1. 
	//Values outside the array are returned as null
	const subArray = [];
	for (let i = y0; i <= y1; i++) {
			const subRow = [];
			for (let j = x0; j <= x1; j++) {
					if (i >= 0 && i < array.length &&
								j >= 0 && j < (array[i] ? array[0].length : 0)) {
							subRow.push({y:i, x:j, t:array[i][j]});
					} 
					else {
							subRow.push({y:i, x:j, t:null});
					}
			}
			subArray.push(subRow);
	}
	return subArray;
}
function getLineArray(array, x0, x1, y0, y1) {
		let points = [];
		
		let dx = Math.abs(x1 - x0);
		let dy = Math.abs(y1 - y0);
		
		let sx = (x0 < x1) ? 1 : -1;
		let sy = (y0 < y1) ? 1 : -1;

		let err = dx - dy;

		while (true) {
				// Put the point into the array
				if (array[y0] && array[y0][x0] !== undefined) {
						points.push({x:x0, y:y0, t:array[y0][x0]});
				}

				if ((x0 === x1) && (y0 === y1)) break;
				let e2 = 2 * err;

				// EITHER move horizontally, OR move vertically, OR move in both directions
				if (e2 > -dy) { err -= dy; x0 += sx; }
				if (e2 < dx) { err += dx; y0 += sy; }
		}

		return points;
}
function get32float(array, offset, reverse=false) {
		const buffer = new ArrayBuffer(8);
		const view = new DataView(buffer);
		if(reverse) {
			view.setUint8(3,array[offset+0]);
			view.setUint8(2,array[offset+1]);
			view.setUint8(1,array[offset+2]);
			view.setUint8(0,array[offset+3]);
		} else {
			view.setUint8(0,array[offset]);
			view.setUint8(1,array[offset+1]);
			view.setUint8(2,array[offset+2]);
			view.setUint8(3,array[offset+3]);
		}    
		return view.getFloat32(0);
}
function get32u(array, offset, reverse=false) {
	if(reverse) {
		return array[offset+3]<<24 | array[offset+2]<<16 | 
				array[offset+1]<<8 | array[offset]<<0;
	}
	return array[offset]<<24 | array[offset+1]<<16 | 
			array[offset+2]<<8 | array[offset+3]<<0;
}
function get32s(array, offset, reverse=false) {
	//TODO
	//apparently get32u will return negative values already?
	return get32u(array, offset, reverse);
}
function get32u_array(array, offset, len, reverse=false) {
	let array_32u=[];
	for(let i=0; i<len; i++) {
		array_32u.push(get32u(array, offset+(4*i), reverse));
	}
	return array_32u;
}
function get16u(array, offset,reverse=false) {
	if(reverse) {
		return array[offset+1]<<8 | array[offset]<<0;
	}
	return array[offset]<<8 | array[offset+1]<<0;
}
function get16u_array(array, offset, len, reverse=false) {
	let array_16u=[];
	for(let i=0; i<len; i++) {
		array_16u.push(get16u(array, offset+(2*i), reverse));
	}
	return array_16u;
}
function getstring(array, offset, len, reverse=false) {
	let string="";
	for(let i=0; i<len; i++) {
		string+=String.fromCharCode(array[offset+i]);
	}
	return string;
}
function concatenateUint8Arrays(...arrays) {
		let totalLength = 0;
		for (let arr of arrays) {
				totalLength += arr.length;
		}
		let result = new Uint8Array(totalLength);
		let offset = 0;
		for (let arr of arrays) {
				result.set(arr, offset);
				offset += arr.length;
		}
		
		return result;
}
function calcCanvasSize(arrayWidth, arrayHeight, divWidth, divHeight) {
	const newHeight = Math.floor(divHeight/arrayHeight)*arrayHeight;
	const newWidth = Math.floor(divWidth/arrayWidth)*arrayWidth;
	return {width:newWidth, height:newHeight}
}
function calcGraphicPixelScale(drawInstructions, arrayWidth, arrayHeight, 
		canvasWidth, canvasHeight) {
	const pixelScaleX = Math.floor(canvasWidth/arrayWidth);
	const pixelScaleY = Math.floor(canvasHeight/arrayHeight);
	for (let instruction of drawInstructions) {
		instruction.pixelScale={x:pixelScaleX, y:pixelScaleY};
	}
	return drawInstructions;
}
function calcArrayLocfromPixelLoc(pixelX, pixelY, arrayWidth, arrayHeight, 
		canvasWidth, canvasHeight) {
	const arrayX = Math.floor(arrayWidth * pixelX / canvasWidth);
	const arrayY = Math.floor(arrayHeight * pixelY / canvasHeight);
	return {x:arrayX, y:arrayY};
}

class ColorPaletteModel extends EventEmitter{
	constructor() {
		super();
		this.minValue = 0;
		this.maxValue = 100;
		this.palette = [[0,0,0],[255,255,255]];
	}
	initializePalette(valueArray) {
		let minValue = Infinity;
		let maxValue = -Infinity;
		for (let row of valueArray) {
			if(Array.isArray(row)) {
				for (let value of row) {
					if (!isNaN(value)) {
						minValue = Math.min(minValue, value);
						maxValue = Math.max(maxValue, value);
					}
				}
			} else {
				if (!isNaN(value)) {
					minValue = Math.min(minValue, row);
					maxValue = Math.max(maxValue, row);
				}
			}
		}
		this.minValue = minValue;
		this.maxValue = maxValue;
	}
	changePaletteValue() {
		this.emit("palettechange",{});
	}
	nullColor() {
		return `rgb(0,0,0)`;
	}
	getColorForIndex(index) {
		const idx1 = Math.floor(index);
		const idx2 = Math.min(idx1 + 1, this.palette.length - 1);
		if (idx1 == idx2) {
				const color = this.palette[idx1];
				return `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
		}
		const t = index - idx1;
		const color1 = this.palette[idx1];
		const color2 = this.palette[idx2];
		const r = Math.round(color1[0] + (t * (color2[0]-color1[0])));
		const g = Math.round(color1[1] + (t * (color2[1]-color1[1])));
		const b = Math.round(color1[2] + (t * (color2[2]-color1[2])));
		return `rgb(${r}, ${g}, ${b})`;
	}
	getColorForValue(value) {
		let valueIndex = 0;
		if (value>this.maxValue) {
			valueIndex = this.palette.length - 1;
		} else if (value<this.minValue) {
			valueIndex = 0;
		}	else {
			valueIndex = (this.palette.length-1)*
					(value-this.minValue)/(this.maxValue-this.minValue);
		}
		return this.getColorForIndex(valueIndex);
	}
	getGradientArray(lowValue, highValue) {
		let lowIndex=0;
		if(lowValue>this.maxValue) {
			lowIndex=this.palette.length-1;
		} else if(lowValue<this.minValue) {
			lowIndex=0;
		}	else {
			lowIndex=(this.palette.length-1)*
					(lowValue-this.minValue)/(this.maxValue-this.minValue);
		}
		let highIndex=0;
		if (highValue>this.maxValue) {
			highIndex=this.palette.length-1;;
		} else if (highValue<this.minValue) {
			highIndex=0;
		}	else {
			highIndex=(this.palette.length-1)*
					(highValue-this.minValue)/(this.maxValue-this.minValue);
		}
		let gradientArray = [{offset:0, color:this.getColorForIndex(lowIndex)}];
		let indexRange = highIndex-lowIndex;
		for(let i=Math.floor(lowIndex)+1; i<highIndex; i++) {
			const offset = (i-lowIndex) / indexRange;
			gradientArray.push({offset:offset, color:this.getColorForIndex(i)});
		}
		gradientArray.push({offset:1, color:this.getColorForIndex(highIndex)});
		return gradientArray;
	}
}
class ViridisPalette extends ColorPaletteModel{
	constructor() {
		super();
		this.palette = [
				[68,1,84],
				[72,40,120],
				[62,74,137],
				[49,104,142],
				[38,130,142],
				[31,158,137],
				[53,183,121],
				[109,205,89],
				[180,222,44],
				[253,231,37]
		];
	}
}
class ViridisPalette2 extends ColorPaletteModel{
	constructor() {
		super();
		this.palette = [
				[68, 1, 84],
				[71, 16, 90],
				[72, 28, 97],
				[70, 41, 106],
				[65, 53, 115],
				[57, 66, 123],
				[49, 78, 131],
				[42, 91, 140],
				[36, 103, 148],
				[32, 116, 156],
				[30, 128, 164],
				[34, 140, 170],
				[47, 152, 174],
				[68, 164, 175],
				[94, 175, 173],
				[121, 185, 168],
				[149, 194, 160],
				[177, 201, 149],
				[204, 207, 135],
				[229, 211, 120],
				[252, 213, 106],
				[255, 217, 96],
				[255, 221, 92],
				[255, 224, 89],
				[255, 228, 86],
				[255, 231, 86],
				[255, 235, 88],
				[255, 238, 90],
				[255, 242, 92],
				[255, 245, 94],
				[255, 248, 99],
				[255, 251, 104],
				[255, 254, 112],
				[255, 255, 121],
				[255, 255, 130],
				[255, 255, 139],
				[255, 255, 148],
				[255, 255, 157],
				[255, 255, 166],
				[255, 255, 174],
				[255, 255, 183],
				[255, 255, 191],
				[255, 255, 199],
				[255, 255, 207],
				[255, 255, 215],
				[255, 255, 221],
				[255, 255, 228],
				[255, 255, 234],
				[255, 255, 239],
				[255, 255, 244],
				[255, 255, 248],
				[255, 255, 252]
		];
	}
}
</script>

<script>
	//top level functions and control
	let loadedTools = {};
	let loadedFiles = {};

	let irAnalysisController = null;
	let colorPaletteModel = null;
	let thermalImageView = null;
	let toolView = null;
	let analysisView = null;

	const g_AnalysisGraph_FontSize = 14;
	const g_AnalysisGraph_Font = "Arial";
	const g_AnalysisGraph_FontColor = 'rgba(192,190,190)';
	const g_AnalysisGraph_AxisColor = 'rgba(192,190,190)';

	function startup() {
		console.log("Main: startup")
		thermalImageView = new ThermalImageView(
				"id_thermalCanvas");
		toolView = new ToolView(
				"id_toolCanvas");
		colorPaletteModel = new ViridisPalette();
		analysisView = new AnalysisView(
				"id_analysisContainer")
		irAnalysisController = new IrAnalysisController(
				"id_thermalCanvasContainer",
				"id_thermalCanvasSizeContainer");
		irAnalysisController.activateColorPalette(colorPaletteModel);
		irAnalysisController.setThermalImageView(thermalImageView);
		irAnalysisController.setToolView(toolView);
		irAnalysisController.setAnalysisView(analysisView);

		const loadedFilesContainer = document.getElementById('id_loadedFiles');
		loadedFilesContainer.ondragover = 
				loadedFilesContainer.ondragenter = function(event) {
					event.preventDefault();
				};
		loadedFilesContainer.ondrop = dropFiles;
		setRandomBackground();
	}

	function setRandomBackground() {
			// Create a canvas element
			let canvas = document.createElement('canvas');
			let ctx = canvas.getContext('2d');
			canvas.width = 300;
			canvas.height = 300;

			// Function to generate a random color
			function randomColor(a=0.3,bright=10) {
				let offset=Math.floor(Math.random()*bright);
				let r=33+offset;
				let g=33+offset;
				let b=34+offset;

				r += 1-Math.floor(Math.random() * 2);
				g += 1-Math.floor(Math.random() * 2);
				b += 1-Math.floor(Math.random() * 2);
				return 'rgba('+r+','+g+','+b+','+a+')';
			}

			function drawPixels(size,alpha,chance,bright) {
				let ox = Math.floor(Math.random()*size);
				let oy = Math.floor(Math.random()*size);
				let ocx = Math.floor(canvas.width/2);
				let ocy = Math.floor(canvas.height/2);
				for (let x = 0; x < (canvas.width/size); x++) {
						for (let y = 0; y < (canvas.height/size); y++) {
							if(Math.random()<chance){
								let sx = Math.floor((x*size)-(size/2));
								let sy = Math.floor((y*size)-(size/2));
								ctx.fillStyle = randomColor(alpha,bright);
								ctx.fillRect(ox+sx+ocx, oy+sy+ocy, size, size);
								ctx.fillRect(ox+sx+ocx, oy+sy-ocy, size, size);
								ctx.fillRect(ox+sx-ocx, oy+sy+ocy, size, size);
								ctx.fillRect(ox+sx-ocx, oy+sy-ocy, size, size);
							}
						}
					}
			}
			ctx.fillStyle = 'rgba(24,21,22,1)';
			ctx.fillRect(0,0,canvas.width,canvas.height);
			drawPixels(5,0.3,0.6,30);
			drawPixels(25,0.4,0.7,5);
			drawPixels(60,0.3,0.9,10);

			ctx.strokeStyle='black';
			ctx.lineWidth='2px';
			//ctx.strokeRect(0,0,canvas.width,canvas.height);
			let dataURL = canvas.toDataURL('image/png');
			document.body.style.backgroundImage = 'url(' + dataURL + ')';
			document.body.style.backgroundRepeat = 'repeat';
	}

	function handleFileUpload(files) {
		console.log("loading a file")
		for(let i=0; i<files.length; i++) {
			const irFile = files[i];
			if (!irFile) { 
				console.log("handleFileUpload: No file selected.");
			} else {
				let thermalArrayModel = new ThermalArrayModel();
				thermalArrayModel.parseFile(irFile).then(() => {
					let fileInstance = 
							new FileInstanceView(thermalArrayModel,"id_loadedFiles");
					irAnalysisController.addFileInstanceView(fileInstance);
				});
			}
		}
	}

	function dropFiles(event) {
		handleFileUpload(event.dataTransfer.files);
		event.preventDefault();
	}

	function chooseFiles() {
		const fileInput = document.getElementById('id_fileInput');
		handleFileUpload(fileInput.files)
	}

	function addTool(selectId, globalTool=false) {
		const selectElement = document.getElementById(selectId);
		let toolModel=null;
		switch ( selectElement.value) {
			case "windowTool":
				toolModel = new WindowTool();
				break;
			case "profileTool":
				toolModel = new ProfileTool();
				break;
		}

		let toolListId = "";
		if(globalTool) {
			toolListId = "id_availGlobalTools";
		} else {
			toolListId = "id_availLocalTools";
		}
		let toolView = new ToolInstanceView(toolModel, toolListId);
		irAnalysisController.addToolInstanceView(toolView, globalTool);
	}
</script>
</head>

<body onload="startup()">
	<div class="page_container"
			style="width:100%; height:100%">

			<div class="apptitle"
					style="padding: 4px;">
				<h1>Thermal Image Analysis</h1></div>

			<div class="appgraphics flexcol_container"
					style="padding:10px; padding-right:5px;">
				<div class="flexcol_container flexele_both"
						style="height:100%; width:100%;">
					<div class="flexcol_container flexele_both" 
							style="width: 100%; height: 50%; justify-content: center;"
							id="id_thermalCanvasContainer">
						<div class="flexcol_container thermgraphics_size flexele_fixed bglight bgblur" 
								style="height: auto; width: auto; margin: 0 auto; border-radius:10px;"
								id="id_thermalCanvasSizeContainer">
							<canvas class="thermcanvas_element" 
									style="z-index: 1;"
									id="id_thermalCanvas"></canvas>
							<canvas class="thermcanvas_element" 
									style="z-index: 2;"
									id="id_toolCanvas"></canvas>
						</div>
					</div>
				</div>
					<div class=" flexrow_container flexele_fixed bglight bgblur" 
							style="height: 20%; width: 100%;"
							id="id_analysisContainer"></div>
			</div>

			<div class="rightbar flexcol_container"
					style="padding:10px; padding-left:5px; height:100%;">

				<div class="flexcol_container bglight bgblur flexele_grow"
						style="padding:10px; width: 100%; height:40%;">
					<div class="flexrow_container flexele_fixed"
							style="width:100%; height:min-content; padding:5px;">
						<h2>Files</h2>
						<input type="button" id="id_loadButton" 
							value="Choose File"
							class="appbtn bgdark" 
							style="margin-left:auto;"
							onclick="document.getElementById('id_fileInput').click();"/>
					</div>

					
					<input type="file" style="display:none;" id="id_fileInput" 
							name="file" multiple="multiple" onchange="chooseFiles()"/>
					<div class="flexlist_container flexele_grow"
							style="height: 50%; width: 100%;"
							id="id_loadedFiles"></div></div>

				<div class="flexcol_container bglight bgblur flexele_grow"
						style="padding:10px; width: 100%; height:40%;">
					<h2>Tools</h2>

					<div class="flexrow_container flexele_fixed"
							style="height:min-content; width:100%;">
						<select id="id_selectGlobalTools" 
								name="global_tools" 
								class="appselect bgdark flexele_grow">
							<option value="windowTool" >Window</option>
							<option value="profileTool" >Profile</option></select>
						<button class="appbtn bgdark" 
								onclick="addTool('id_selectGlobalTools',true)">Add</button></div>
					<div class="flexlist_container flexele_both bgdark"
							style="height:30%; width:100%;"
							id="id_availGlobalTools"></div>

					<div class="flexrow_container flexele_fixed"
							style="height:min-content; width:100%">
						<select id="id_selectLocalTools" 
								name="instance_tools" 
								class="appselect bgdark flexele_grow">
							<option value="windowTool" >Window</option>
							<option value="profileTool" >Profile</option></select>
						<button class="appbtn bgdark" 
								onclick="addTool('id_selectLocalTools',false)">Add</button></div>
					<div class="flexlist_container flexele_both bgdark"
							style="height:30%; width:100%;"
							id="id_availLocalTools"></div>
				</div>

			</div>
	</div>

	<template id="id_genericAnalysisTemplate">
		<div class="analysiscanvas-container">
			<canvas class="flexrow_container" id="id_analysisCanvas"></canvas>
		</div>
		<div class="analysisinfo-container width:0px height:0px">
			Average:<span class="analysisText" id="id_analysisAvg"></span><br>
			Minimum:<span class="analysisText" id="id_analysisMin"></span><br>
			Maximum:<span class="analysisText" id="id_analysisMax"></span><br>
		</div>
	</template>

	<template id="id_fileInstanceTemplate">
		<div id="id_fileInstance" 
				class="flexrow_container flexele_fixed hover-light"
				style="width:100%; height:25%; padding:10px;">

			<img id="id_instanceImage" 
					class="flexele_fixed"
					style="width:40%; height:100%; object-fit: contain; object-position: center;">
			</img>

			<div class="flexele_both flexrow_container"
					style="width:60%; flex-wrap: wrap; gap:16px;">
				<input type='text' id="id_instanceName" 
						class="appinput bgdark"
						style="width:100%; height:min-content; margin:0 auto;">
				<div id="id_instanceRename" 
						class="appbtn_circle bgdark">
					💾
				</div>
				<div id="id_instanceDelete" 
						class="appbtn_circle bgdark">
					🗑️
				</div>
				<div id="id_Btn3" 
						class="appbtn_circle bgdark">
					🗑️
				</div>
			</div>
		</div>
	</template>

	<template id="id_toolInstanceTemplate">
		<div id="id_fileInstance" 
				class="flexrow_container  flexlist_item"
				style="width:100%; height:min-content; gap:4px;">
			<input type='text' id="id_instanceName" 
					class="appinput bgdark flexele_grow"
					style="height:100%; margin:0 auto;">
			<div id="id_instanceScope" 
					class="flexele_fixed appbtn_circle hover-green">
				📝
			</div>
			<div id="id_instanceDelete" 
					class="flexele_fixed appbtn_circle hover-red">
				🗑️
			</div>
			<div id="id_instanceSave" 
					class="flexele_fixed appbtn_circle hover-red">
				💾
			</div>
		</div>
	</template>
</body>
</html>




