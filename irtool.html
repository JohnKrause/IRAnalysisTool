<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Thermal Image Analysis</title>
<link rel="stylesheet" href="styles.css">
<style>
	* {
		margin: 0;
		padding: 0;
		box-sizing: border-box;
		}

	body, html {
		font-family: Arial, sans-serif;
		background-color: #555;
		padding: 0px;
		height: 100%;
	}
	.page-container {
		margin: 0;
		display: flex;
		flex-direction: column;
		width: 100%;
		height: 100%;
	}
	.title-container {
		width: 100%;
		height: auto;
		margin: 0px;
		background-color: rgba(0,0,0,0);
	}
	.title-container h1 {
		margin: 5px;
		text-align: left;
	}
	.app-container {
		margin: 0;
		display: flex;
		flex-direction: row;
		width: 100%;
		height: 100%;
	}
	.tool-container {
		width: 20%;
		height: auto;
		margin:10px;
		padding: 10px;
		background-color: rgba(25,200,255,0.1);
		box-shadow: 0px 0px 10px rgba(0,0,0,0.1);
	}
	.thermalanalytics-container{
		width: 80%;
		height: auto;
		margin:10px;
		padding: 10px;

		display: flex;
		flex-direction: column;
		background-color: rgba(25,200,255,0.1);
		box-shadow: 0px 0px 10px rgba(0,0,0,0.1);
	}
	.thermalcanvas-container{
		margin: 0px;
		height: 80%;
		width: auto;
	}
	.measurements-container{
		margin: 0px;
		height: 20%;
		width: auto;
	}
	.thermalcanvas-element {
		border: solid;
	}
	.thermalcanvas-element:hover {
		cursor: crosshair;
	}
</style>

<script>
//top level functions and control
let thermalCanvas = null;
let windowWidth = 0;
let windowHeight = 0;
let irAnalysisController = null;
let colorPalette = null;
let pointerTool = null;
let loadedTools = {};
let loadedFiles = {};


function startup() {
	console.log("startup")
	irAnalysisController = new IrAnalysisController("id_thermalCanvas","");
	colorPalette = new ViridisPalette();
	pointerTool = new PointerTool();
	irAnalysisController.setActiveColorPaletteModel(colorPalette);
	irAnalysisController.setActiveToolModel(pointerTool);
}

function handleFileUpload() {
	const fileInput = document.getElementById('fileInput');
	const irFile = fileInput.files[0];
	if (!irFile) { 
		console.log("No file selected.");
	} else {
		const irThermalArrayModel = new IrThermalArrayModel();
		irThermalArrayModel.parseFile(irFile).then(() => {
			loadedFiles['1']={};
			loadedFiles['1'].irThermalArrayModel = irThermalArrayModel;
			loadedFiles['1'].file = irFile;;
			irAnalysisController.setActiveThermalArray(irThermalArrayModel);
			setCanvasSize();
		});
	}
	return;
}

function activatePointerTool() {
	toolManager.changeTool(toolPointer);
}

function newTemperatureData() {
	thermalCanvas.updateCanvas();
	toolManager.updateCanvas();
}

function setCanvasSize() {
	availableWidth=document.getElementById('id_thermalCanvasContainer')
			.offsetWidth;
	availableHeight=document.getElementById('id_thermalCanvasContainer')
			.offsetHeight;
	irAnalysisController.setAvailableSize(availableWidth,availableHeight);
}

function resizeWindow() {
	setCanvasSize();
}

class IrAnalysisController {
	constructor(irCanvasId, toolDivId) {
		window.addEventListener('resize', this.resizeWindow.bind(this));
		this.availableHeight = 0;
		this.availableWidth = 0;
		this.thermalCanvas = document.getElementById(irCanvasId);
		this.thermalCanvasIrBuffer = document.createElement('canvas');
		this.thermalCanvasIrBuffer.width = this.thermalCanvas.width;
		this.thermalCanvasIrBuffer.height = this.thermalCanvas.height;
		this.thermalCanvasToolBuffer = document.createElement('canvas');
		this.thermalCanvasToolBuffer.width = this.thermalCanvas.width;
		this.thermalCanvasToolBuffer.height = this.thermalCanvas.height;
		this.irThermalArrayView = new IrThermalArrayView();

		this.activeToolModel = null;
		this.activeThermalArrayModel = null;
		this.activeColorPalette = null;

		this.thermalArrayLoaded=false;
		this.toolLoaded=false;
		this.colorPaletteLoaded=false;
		this.lastArrayX=-1;
		this.lastArrayY=-1;
	}

	setActiveToolModel(activeToolModel) {
		if(!this.toolLoaded) {
			this.thermalCanvas.addEventListener('mousedown', 
					this.#mouseDown.bind(this));
			this.thermalCanvas.addEventListener('mouseup', 
					this.#mouseUp.bind(this));
			this.thermalCanvas.addEventListener('wheel', 
					this.#mouseWheel.bind(this));		
			this.thermalCanvas.addEventListener('mouseout', 
					this.#mouseOut.bind(this));
			this.thermalCanvas.addEventListener('mousein', 
					this.#mouseIn.bind(this));
			this.thermalCanvas.addEventListener('mousemove', 
					this.#mouseMove.bind(this));
		}
		this.activeToolModel = activeToolModel;
		this.toolLoaded = true;
		this.#redraw();
	}

	setActiveThermalArray(targetThermalArrayModel) {
		this.activeThermalArrayModel = targetThermalArrayModel;
		this.thermalArrayLoaded = true;
		this.#redraw();
	}

	setActiveColorPaletteModel(targetColorPaletteModel) {
		this.activeColorPaletteModel = targetColorPaletteModel;
		this.irThermalArrayView.setActiveColorPaletteModel(targetColorPaletteModel);
		this.colorPaletteLoaded = true;
		this.#redraw();
	}

	setAvailableSize(availableWidth, availableHeight) {
		const thermalArray = this.activeThermalArrayModel.getThermalArray();
		const arrayHeight = thermalArray.length;
		const arrayWidth = thermalArray[0].length;
		const newHeight = Math.floor(availableHeight/arrayHeight)*arrayHeight;
		const newWidth = Math.floor(availableWidth/arrayWidth)*arrayWidth;
		if(newWidth!=this.thermalCanvas.width || 
				newHeight!=this.thermalCanvas.height) {
			this.thermalCanvas.width=newWidth;
			this.thermalCanvas.height=newHeight;
			this.thermalCanvasIrBuffer.width=newWidth;
			this.thermalCanvasIrBuffer.height=newHeight;
			this.thermalCanvasToolBuffer.width=newWidth;
			this.thermalCanvasToolBuffer.height=newHeight;
			this.#redraw();
		}
	}

	#redraw() {
		if(this.colorPaletteLoaded && this.thermalArrayLoaded && this.toolLoaded) {
			console.log("Redrawing thermal canvas...")
			//Draw the IR image array
			const thermalArray = this.activeThermalArrayModel.getThermalArray();
			this.irThermalArrayView.drawThermalArray(thermalArray, 
					this.thermalCanvasIrBuffer);
			//Updat the tool calculation then draw it's cursor
			this.activeToolModel.calculateAnalytics(thermalArray);
			this.activeToolModel.drawCursor(thermalCanvasToolBuffer);
			//copy contents of both buffers onto the display canvas
			const thermalCanvasCtx = this.thermalCanvas.getContext('2d');
			thermalCanvasCtx.drawImage(this.thermalCanvasIrBuffer,0,0);
			thermalCanvasCtx.drawImage(this.thermalCanvasToolBuffer,0,0);
		}
	}
	#drawTool() {
		const currentToolOverlay = this.activeToolModel.getOverlay();
		this.toolOverlayView.update(currentToolOverlay);
		const currentToolAnalysis = this.activeToolModel.getAnalysis();
		this.toolAnalysisView.update(currentToolAnalysis);
	}
	#mouseDown(event) {
		this.activeToolModel.mouseDown();
	}
	#mouseUp(event) {
		this.activeToolModel.mouseUp();
	}
	#mouseWheel(event) {
		this.activeToolModel.mouseDown(event.deltaX, event.deltaY);
	}
	#mouseOut(event) {
		this.activeToolModel.mouseOut();
	}
	#mouseIn(event) {
		this.activeToolModel.mouseIn();
	}
	#mouseMove(event) {
		if (this.thermalArrayLoaded) {
			const thermalArray = this.activeThermalArrayModel.getThermalArray();
			const arrayX = Math.floor(thermalArray[0].length * event.offsetX 
					/ this.thermalCanvas.width);
			const arrayY = Math.floor(thermalArray.length * event.offsetY 
					/ this.thermalCanvas.height);
			this.activeToolModel.mouseMove(arrayX, arrayY);	
			if(this.lastArrayX!=arrayX || this.lastArrayY!=arrayY) {
				this.#redraw();
			}
		}
	}
	#resizeWindow(event) {
		if(this.thermalArrayLoaded) {
			const availableWidth = this.thermalCanvas.parentElement.offsetWidth;
			const availableHeight = this.thermalCanvas.parentElement.offsetHeight;
			const thermalArray = this.activeThermalArrayModel.getThermalArray();
			const arrayHeight = thermalArray.length;
			const arrayWidth = thermalArray[0].length;
			const newHeight = Math.floor(availableHeight/arrayHeight)*arrayHeight;
			const newWidth = Math.floor(availableWidth/arrayWidth)*arrayWidth;
			if(newWidth!=this.thermalCanvas.width || 
					newHeight!=this.thermalCanvas.height) {
				this.thermalCanvas.width=newWidth;
				this.thermalCanvas.height=newHeight;
				this.thermalCanvasIrBuffer.width=newWidth;
				this.thermalCanvasIrBuffer.height=newHeight;
				this.thermalCanvasToolBuffer.width=newWidth;
				this.thermalCanvasToolBuffer.height=newHeight;
				this.#redraw();
			}
		}
	}
}

class AnalysisTool {
	static name() {return "Analysis Tool";}
	mouseWheel(deltaX, deltaY) {;}
	mouseUp() {;}
	mouseDown() {;}
	mouseIn() {;}
	mouseOut() {;}
	mouseMove(arrayX, arrayY) {;}
	keyboard(key) {;}
	calculateAnalytics(thermalArray) {;}
	drawCursor(toolCanvas){;}
	drawGraph(graphCanvas){;}
	drawAnalytics(analyticsDiv){;}
}

class PointerTool extends AnalysisTool {
	static name() {return "Pointer Tool";}
	constructor() {
		this.boxWidth=3;
		this.boxHeight=3;
		this.mouseX=null;
		this.mouseY=null;
		this.dragging=false;
		this.thermalArray=null;
		this.analytics={minTemp:{},maxTemp:{},x:0,y:0,tArray:[],boxW:0,boxH:0};
	}
	mouseWheel(deltaX, deltaY) {
		if(deltaY < 0) {
			this.boxWidth+=1;
			this.boxHeight+=1;
		}
		else if(deltaY > 0 && this.boxWidth>3) {
			this.boxWidth-=1;
			this.boxHeight-=1;
		}
	}
	mouseUp() {
		this.dragging=false;
	}
	mouseDown() {
		this.dragging=true;
	}
	mouseIn() {;}
	mouseOut() {
		this.dragging=false;
	}
	mouseMove(arrayX, arrayY) {
		if(this.dragging) {
			this.mouseX=arrayX;
			this.mouseY=arrayY;
		}
	}
	calculateAnalytics(thermalArray) {
		this.thermalArray=thermalArray;
		if(this.mouseX===null || this.mouseY===null) {
			this.mouseY=Math.Floor(this.thermalArray.length/2);
			this.mouseX=Math.Floor(this.thermalArray[0].length/2);
		}
		this.getCursorAnalytics();
	}
	drawCursor(toolCanvas){
			const arrayHeight = this.analytics.thermalArray.length;
			const arrayWidth = this.analytics.thermalArray[0].length;
			const canvasHeight = toolCanvas.height;
			const canvasWidth = toolCanvas.width;
			const toolCanvasCtx = toolCanvas.getContext('2d');
			const widthPixelScale = Math.floor(canvasWidth / arrayWidth);
			const heightPixelScale = Math.floor(canvasHeight / arrayHeight);
			//Draw the window outline box
			toolCanvasCtx.strokeStyle='black';
			toolCanvasCtx.lineWidth=3;
			toolCanvasCtx.clearRect(0,0,canvasWidth, canvasHeight);
			const boxXPixels =(this.analytics.x-this.analytics.boxW)
					*widthPixelScale;
			const boxYPixels =(this.analytics.y-this.analytics.boxH)
					*heightPixelScale;
			const boxWPixels =((2*this.analytics.boxW)+1)
					*widthPixelScale;
			const boxHPixels =((2*this.analytics.boxH)+1)
					*heightPixelScale;
			toolCanvasCtx.strokeRect(boxXPixels, boxYPixels, 
					boxWPixels, boxHPixels);
			//Draw the centerpoint
			const centerXPixels =(this.analytics.x * widthPixelScale);
			const centerYPixels =(this.analytics.y * heightPixelScale);
			const centerHeightPixels = (heightPixelScale+1);
			const centerWidthPixels = (widthPixelScale+1);
			toolCanvasCtx.lineWidth=1;
			toolCanvasCtx.strokeRect(centerXPixels, centerYPixels, 
					centerHeightPixels, centerWidthPixels);
			//Draw the minimum temperature
			const minimumXPixels =(this.analytics.minTemp.x * widthPixelScale);
			const minimumYPixels =(this.analytics.minTemp.y * heightPixelScale);
			const minimumHeightPixels = (heightPixelScale+1);
			const minimumWidthPixels = (widthPixelScale+1); 
			toolCanvasCtx.strokeStyle='blue';
			toolCanvasCtx.lineWidth=2;
			toolCanvasCtx.strokeRect(minimumXPixels, minimumYPixels, 
					minimumHeightPixels, minimumWidthPixels);
			//Draw the maximum temperature
			const maximumXPixels =(this.analytics.maxTemp.x * widthPixelScale);
			const maximumYPixels =(this.analytics.maxTemp.y * heightPixelScale);
			const maximumHeightPixels = (heightPixelScale+1);
			const maximumWidthPixels = (widthPixelScale+1); 
			toolCanvasCtx.strokeStyle='red';
			toolCanvasCtx.lineWidth=2;
			toolCanvasCtx.strokeRect(maximumXPixels, maximumYPixels, 
					maximumHeightPixels, maximumWidthPixels);
	}
	drawGraph(graphCanvas){;}
	drawAnalytics(analyticsDiv){;}
	#getCursorAnalytics() {
		const x0 = this.mouseX-this.boxWidth;
		const x1 = this.mouseX+this.boxWidth;
		const y0 = this.mouseY-this.boxHeight;
		const y1 = this.mouseY+this.boxHeight;
		let cursorThermalArray = getSubArray(this.thermalArray, x0, x1, y0, y1);
		let minTemp = {
			t: Infinity,
			x: -1,
			y: -1
		};
		let maxTemp = {
			t: -Infinity,
			x: -1,
			y: -1
		};
		for (let i = 0; i < cursorThermalArray.length; i++) {
			for (let j = 0; j < cursorThermalArray[i].length; j++) {
				const currentTemp = cursorThermalArray[i][j];
				if (typeof currentTemp === 'number') {
					if (currentTemp < minTemp.t) {
						minTemp.t = currentTemp;
						minTemp.x = j+x0;
						minTemp.y = i+y0;
					}
					if (currentTemp > maxTemp.t) {
						maxTemp.t = currentTemp;
						maxTemp.x = j+x0;
						maxTemp.y = i+y0;
					}
				}
			}
		}
		this.analytics.minTemp=minTemp;
		this.analytics.maxTemp=maxTemp;
		this.analytics.tArray=cursorThermalArray;
		this.analytics.boxW=this.boxWidth;
		this.analytics.boxH=this.boxHeight;
		this.analytics.x=this.mouseX;
		this.analytics.y=this.mouseY;
		this.analytics.thermalArray = this.thermalArray;
	}
}


class IrThermalArrayView {
	constructor() {
		this.activeColorPaletteModel=null;
		this.colorRangeMin=100;
		this.colorRangeMax=400;
		this.colorRangeFixed=false;
	}

	setActiveColorPaletteModel(targetColorPaletteModel) {
		this.activeColorPaletteModel = targetColorPaletteModel;
	}

	setColorPaletteRange(rangeMode, rangeMin, rangeMax) {
		if(rangeMode === 'fixed') {
			this.colorRangeFixed=true;
			this.colorRangeMin = rangeMin;
			this.colorRangeMax = rangeMax;
		} else { //adaptive
			this.colorRangeFixed=false;
		}
	}

	drawThermalArray(thermalArray, thermalCanvas) {
		if(this.activeColorPaletteModel===null) {
			throw "No chosen color palette";
		}
		if(!thermalArray) {
			throw "No thermal array";
		}
		console.log(`IrThermalArrayView: Drawing thermal array`);
		let minTemp = Infinity;
		let maxTemp = -Infinity;
		if(this.colorRangeFixed) {
			minTemp = this.colorRangeMin;
			maxTemp = this.colorRangeMax;
		} else {
			//Find min and max temperatures in array
			for (let row of thermalArray) {
				for (let temp of row) {
					if (!isNaN(temp)) {
						minTemp = Math.min(minTemp, temp);
						maxTemp = Math.max(maxTemp, temp);
					}
				}
			}
		}
		//Set the min/max temperatures in the color palette
		this.activeColorPaletteModel.setMinMaxValues(minTemp,maxTemp);
		//Find the correct pixel scale (pixels per array element)
		const arrayHeight = thermalArray.length;
		const arrayWidth = thermalArray[0].length;
		const canvasHeight = thermalCanvas.height;
		const canvasWidth = thermalCanvas.width;
		const thermalCanvasCtx = thermalCanvas.getContext('2d');
		const widthPixelScale = Math.floor(canvasWidth / arrayWidth);
		const heightPixelScale = Math.floor(canvasHeight / arrayHeight);
		//Render each element of the array as a rectangle
		//Rectangle has sides according to widthpixelscale / heightpixelscale
		thermalCanvasCtx.clearRect(0,0,canvasWidth, canvasHeight);
		for (let y = 0; y < arrayHeight; y++) {
			for (let x = 0; x < arrayWidth; x++) {
				const pixelTemperature = thermalArray[y][x];
				thermalCanvasCtx.fillStyle = 
						this.activeColorPaletteModel.getColorForValue(pixelTemperature);
				thermalCanvasCtx.fillRect(
						x*widthPixelScale, 
						y*heightPixelScale, 
						widthPixelScale, 
						heightPixelScale);
			}
		}
	}
}

class IrThermalArrayModel {
	constructor() {
		console.log("IrThermalArrayModel: make array model");
		this.thermalArray=[];
		this.irThermalImageModel = new IrThermalImageModel();
	}

	getThermalArray() {
		return this.thermalArray;
	}

	parseFile(irFile) {
		return new Promise((resolve, reject) => {
			this.irThermalImageModel.loadFile(irFile).then(() => {
				this.createThermalArray();
				resolve();
			}).catch((error) => {
				reject(new Error(error));
			});
		});
		
	}

	createThermalArray() {
		const rawData=this.irThermalImageModel.dataFLIR.rawData;
		const cameraData=this.irThermalImageModel.dataFLIR.cameraData;
		if(!rawData || !cameraData) {
			throw "Did not find raw camera data";
		}
		this.thermalArray=[];
		if(rawData['ThermalImage'].length < 
				(rawData['ImageHeight'] * rawData['ImageWidth'])) {
			throw "ThermalImage has wrong length (not Height * Width)";
		}
		this.arrayRendered=false;
		const e = Math.E;
			const R1 = cameraData[ 'PlanckR1'];
			const R2 = cameraData[ 'PlanckR2'];
			const B = cameraData[ 'PlanckB'];
			const F = cameraData[ 'PlanckF'];
			const O = cameraData[ 'PlanckO'];
			const T_refl = cameraData[ 'ReflectedApparentTemperature'];
			const Emissivity = cameraData[ 'Emissivity'];

		for (let h=0; h<rawData['ImageHeight']; h++) {
			let row=[];
			let rowOffset = h*rawData['ImageWidth'];
			for (let w=0; w<rawData['ImageWidth']; w++) {
					const S = rawData['ThermalImage'][rowOffset+w];
					const RAW_refl = R1 / (R2 * (Math.pow(e, B/T_refl) - F)) - O;
					const RAW_obj = (S - (1 - Emissivity) * RAW_refl) / Emissivity;
					const T_obj = B / Math.log(R1 / (R2 * (RAW_obj + O)) + F);
					row.push(T_obj);
			}
			this.thermalArray.push(row)
		}
	}
}

class IrThermalImageModel {
	constructor() {
		this.byteArray=null;
		this.segmentList=[];
		this.bytesFLIR=[];
		this.headerFLIR={};
		this.recordsFLIR={};
		this.dataFLIR={};
	}

	loadFile(irFile) {
		return new Promise((resolve, reject) => {
			var fileReader = new FileReader();

			fileReader.onloadend = () => {
				if (fileReader.result) {
					this.byteArray = new Uint8Array(fileReader.result);
					this.parseFile();
					resolve();
				}
			};

			fileReader.onerror = (error) => {
				reject(new Error(error));
			}

			fileReader.readAsArrayBuffer(irFile);
		});
	}

	parseFile() {
		console.log("find segments");
		this.findSegments();
		console.log(this.segmentList)
		console.log("extract FLIR segments");
		this.extractFLIRSegments();
		console.log(this.bytesFLIR)
		console.log("process FLIR header");
		this.processFLIRHeader();
		console.log(this.headerFLIR);
		console.log("process FLIR records");
		this.processFLIRRecords();
		console.log(this.recordsFLIR)
		console.log("process Raw Data");
		this.processRawData();
		console.log("process Camera Data");
		this.processCameraData();
		console.log(this.dataFLIR)
	}

	findSegments() {
		let i = 0;
		let found_exif = false;
		this.segmentList=[];
		//check that it's a valid jpeg (starts with 0xD8FF)
		if (this.byteArray[i] !== 0xFF || this.byteArray[i + 1] !== 0xD8) {
			throw "Not a valid JPEG file";
		}
		i += 2;
		//create list of all jpeg segments 
		//	(segments starts with 0xFFyy where yy isn't 0x00)
		//the list is like [[segment id, segment start index,segment length]]
		while (i < this.byteArray.length) {
			if(this.byteArray[i] == 0xFF){
				if(this.byteArray[i+1] != 0x00){
					let segment_info=[];
					let segment_id = this.byteArray[i + 1];
					if(segment_id==225) {
						found_exif=true;
					}
					let segment_start = i+2;
					let segment_length = 0;
					segment_info.push(segment_id);
					segment_info.push(segment_start)
					segment_length = (this.byteArray[segment_start] << 8) + 
							this.byteArray[segment_start+1];
					if(this.byteArray[segment_start+segment_length]==0xFF && 
							this.byteArray[segment_start+segment_length+1]!=0x00) {
						segment_info.push(segment_length);
						i = segment_start+segment_length;
					} else {
						segment_info.push(0);
						i+=2;
					}
					this.segmentList.push(segment_info);
				} else{i+=2;}
			} else{i+=1;}
		}
		if(!this.segmentList) {throw "Found no segments"}
		if(!found_exif) {throw "Found no EXIF segments"}
	}

	extractFLIRSegments() {
		//compile segments into flir data
		this.bytesFLIR = new Uint8Array([]);
		for(const segment_info of this.segmentList) {
			if(segment_info[0]==225 && segment_info[2]>=0x40) //check if exif segment and large enough for data
			{	
				//prepare to slice up start of segment for identification
				let segment_size_start=segment_info[1];
				let segment_type_start=segment_size_start+2;
				let segment_contents_start=segment_type_start+8; //flir records have 8 bytes of id at beginning
				let segment_size_bytes=segment_info[2];
				let segment_contents_size=segment_size_bytes-(2+8); //excluding 2 byte segment size and 8 byte id
				//Slice up array and determine if FLIR type
				let segment_type_bytes = this.byteArray.slice(segment_type_start, segment_type_start+6);
				let segment_type=""
				for(let i=0; i<6; i++){
					segment_type+=String.fromCharCode(segment_type_bytes[i]);
				}
				//Check that the segment tag is correct
				if(segment_type.startsWith("FLIR")){
					//combine this segment with previous flir segments
					let segment_contents_bytes=this.byteArray.slice(segment_contents_start, segment_contents_start+segment_contents_size);
					this.bytesFLIR = concatenateUint8Arrays(this.bytesFLIR, segment_contents_bytes);
				}
			}
		}
		if(!this.bytesFLIR) {
			throw "Found no FLIR segments"
		}
	}

	processFLIRHeader() 
	{
		if(this.bytesFLIR.length<0x40) {
			throw "FLIR segment is too small"
		}
		let header_bytes=this.bytesFLIR.slice(0, 0x40);
		if(String.fromCharCode(header_bytes[0])=="F" || 
				String.fromCharCode(header_bytes[0])=="A")
		{
			if(String.fromCharCode(header_bytes[1])=="F" 
				&& String.fromCharCode(header_bytes[2])=="F"
				&& header_bytes[3]==0)
			{
				this.headerFLIR={};
				this.headerFLIR['Creator']=getstring(header_bytes,0x04,16);
				this.headerFLIR['Version']=get32u(header_bytes,0x14);
				this.headerFLIR['RecordOffset']=get32u(header_bytes,0x18);
				this.headerFLIR['NumRecords']=get32u(header_bytes,0x1c);
				this.headerFLIR['NextIndex']=get32u(header_bytes,0x20);
				this.headerFLIR['SwapPattern']=get16u(header_bytes,0x24);
				this.headerFLIR['Spares']=get16u_array(header_bytes,0x28, 7);
				this.headerFLIR['Reserved']=get32u_array(header_bytes,0x34, 2);
				this.headerFLIR['Checksum']=get32u(header_bytes,0x3c);
				return;
			}
		}
		throw "FLIR header has invalid start code"
	}

	processFLIRRecords()
	{
		if(this.headerFLIR['NumRecords']>255) {
			throw "Number of records is invalid";
		}
		let records_start_index = this.headerFLIR['RecordOffset'];
		let records_end_index = records_start_index+
				(0x20 * this.headerFLIR['NumRecords']);
		if(records_end_index > this.bytesFLIR.length) {
			throw "FLIR records extend past end of records";
		}
		//Extract the record header sections
		this.bytesRecords=this.bytesFLIR.slice(records_start_index, records_end_index);
		//Extract information for each record
		this.recordsFLIR={}
		for(let i=0; i<this.headerFLIR['NumRecords']; ++i)
		{
			let record={}
			let record_start=i*0x20;
			record['Type']=get16u(this.bytesRecords,record_start+0x00);
			record['SubType']=get16u(this.bytesRecords,record_start+0x02);
			record['Version']=get32u(this.bytesRecords,record_start+0x04);
			record['IndexID']=get32u(this.bytesRecords,record_start+0x08);
			record['RecordOffset']=get32u(this.bytesRecords,record_start+0x0c);
			record['RecordLength']=get32u(this.bytesRecords,record_start+0x10);
			record['Parent']=get32u(this.bytesRecords,record_start+0x14);
			record['ObjectNumber']=get32u(this.bytesRecords,record_start+0x18);
			record['Checksum']=get32u(this.bytesRecords,record_start+0x1c);
			if(record['Type']==0) {
				continue;
			}
			else {
				this.recordsFLIR[record['Type']]=record;
			}
		}
	}

	processRawData()
	{
		if(!this.recordsFLIR.hasOwnProperty(0x01)) {
			throw "FLIR records missing key for raw data";
		}
		let reverse=false;
		let record=this.recordsFLIR[0x01];
		this.dataFLIR["rawData"]={};
		let raw_data={};
		raw_data['ByteOrder'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x00);
		if(raw_data['ByteOrder']>0x0100) {
			reverse=true;
		}
		raw_data['ByteOrder'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x00, reverse);
		raw_data['ImageWidth'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x02, reverse);
		raw_data['ImageHeight'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x04, reverse);
		raw_data['ThermalImage'] = 
		get16u_array(this.bytesFLIR, record['RecordOffset']+0x1E+2, 
				raw_data['ImageWidth']*raw_data['ImageHeight'], reverse)
		this.dataFLIR["rawData"] = raw_data;
	}

	processCameraData()
	{
		if(!this.recordsFLIR.hasOwnProperty(0x20)) {
			throw "FLIR records missing key for camera data";
		}
		let reverse=false;
		let record=this.recordsFLIR[0x20];
		this.dataFLIR["cameraData"]={};
		let camera_data={};
		camera_data['ByteOrder'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x00);
		if(camera_data['ByteOrder']>0x0100) {
			reverse=true;
		}
		camera_data[ 'ByteOrder'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x00, reverse);
		camera_data[ 'Emissivity'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x20, reverse);
		camera_data[ 'ObjectDistance'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x24, reverse);
		camera_data[ 'ReflectedApparentTemperature'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x28, reverse);
		camera_data[ 'AtmosphericTemperature'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x2c, reverse);
		camera_data[ 'IRWindowTemperature'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x30, reverse);
		camera_data[ 'IRWindowTransmission'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x34, reverse);
		camera_data[ 'RelativeHumidity'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x3c, reverse);
		camera_data[ 'PlanckR1'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x58, reverse);
		camera_data[ 'PlanckB'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x5c, reverse);
		camera_data[ 'PlanckF'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x60, reverse);
		camera_data[ 'AtmosphericTransAlpha1'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x070, reverse);
		camera_data[ 'AtmosphericTransAlpha2'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x074, reverse);
		camera_data[ 'AtmosphericTransBeta1'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x078, reverse);
		camera_data[ 'AtmosphericTransBeta2'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x07c, reverse);
		camera_data[ 'AtmosphericTransX'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x080, reverse);
		camera_data[ 'CameraTemperatureRangeMax'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x90, reverse);
		camera_data[ 'CameraTemperatureRangeMin'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x94, reverse);   
		camera_data[ 'CameraTemperatureMaxClip'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x98, reverse);  
		camera_data[ 'CameraTemperatureMinClip'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x9c, reverse);
		camera_data[ 'CameraTemperatureMaxWarn'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0xa0, reverse);
		camera_data[ 'CameraTemperatureMinWarn'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0xa4, reverse);
		camera_data[ 'CameraTemperatureMaxSaturated'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0xa8, reverse);
		camera_data[ 'CameraTemperatureMinSaturated'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0xac, reverse);  
		camera_data[ 'CameraModel'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0xd4, 32);
		camera_data[ 'CameraPartNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0xf4, 16, reverse);
		camera_data[ 'CameraSerialNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x104, 16, reverse);
		camera_data[ 'CameraSoftware'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x114, 16, reverse);
		camera_data[ 'LensModel'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x170, 32, reverse);
		camera_data[ 'LensPartNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x190, 16, reverse);
		camera_data[ 'LensSerialNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x1a0, 16, reverse);
		camera_data[ 'FieldOfView'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x1b4, reverse);
		camera_data[ 'FilterModel'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x1ec, 16, reverse);
		camera_data[ 'FilterPartNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x1fc, 32, reverse);
		camera_data[ 'FilterSerialNumber'] = 
		getstring(this.bytesFLIR, record['RecordOffset']+0x21c, 32, reverse);
		camera_data[ 'PlanckO'] = 
		get32s(this.bytesFLIR, record['RecordOffset']+0x308, reverse);
		camera_data[ 'PlanckR2'] = 
		get32float(this.bytesFLIR, record['RecordOffset']+0x30c, reverse);
		camera_data[ 'RawValueRangeMin'] = 
		get16u(this.bytesFLIR, record['RecordOffset']+0x310, reverse);
		this.dataFLIR["cameraData"] = camera_data;
	}
}



function getSubArray(array, x0, x1, y0, y1) {
	//Returns an subarray from Array from x0,y0 to x1,y1. 
	//Values outside the array are returned as null
	const subArray = [];
	for (let i = y0; i <= y1; i++) {
			const subRow = [];
			for (let j = x0; j <= x1; j++) {
					if (i >= 0 && i < array.length &&
								j >= 0 && j < (array[i] ? array.length : 0)) {
							subRow.push(array[i][j]);
					} 
					else {
							subRow.push(null);
					}
			}
			subArray.push(subRow);
	}
	return subArray;
}
function get32float(array, offset, reverse=false) 
{
		const buffer = new ArrayBuffer(8);
		const view = new DataView(buffer);
		if(reverse) {
			view.setUint8(3,array[offset+0]);
			view.setUint8(2,array[offset+1]);
			view.setUint8(1,array[offset+2]);
			view.setUint8(0,array[offset+3]);
		} else {
			view.setUint8(0,array[offset]);
			view.setUint8(1,array[offset+1]);
			view.setUint8(2,array[offset+2]);
			view.setUint8(3,array[offset+3]);
		}    
		return view.getFloat32(0);
}

function get32u(array, offset, reverse=false)
{
	if(reverse) {
		return array[offset+3]<<24 | array[offset+2]<<16 | 
				array[offset+1]<<8 | array[offset]<<0;
	}
	return array[offset]<<24 | array[offset+1]<<16 | 
			array[offset+2]<<8 | array[offset+3]<<0;
}

function get32s(array, offset, reverse=false)
{
	//TODO
	//apparently get32u will return negative values already?
	return get32u(array, offset, reverse);
}

function get32u_array(array, offset, len, reverse=false)
{
	let array_32u=[];
	for(let i=0; i<len; i++) {
		array_32u.push(get32u(array, offset+(4*i), reverse));
	}
	return array_32u;
}

function get16u(array, offset,reverse=false)
{
	if(reverse) {
		return array[offset+1]<<8 | array[offset]<<0;
	}
	return array[offset]<<8 | array[offset+1]<<0;
}

function get16u_array(array, offset, len, reverse=false)
{
	let array_16u=[];
	for(let i=0; i<len; i++) {
		array_16u.push(get16u(array, offset+(2*i), reverse));
	}
	return array_16u;
}

function getstring(array, offset, len, reverse=false)
{
	let string="";
	for(let i=0; i<len; i++) {
		string+=String.fromCharCode(array[offset+i]);
	}
	return string;
}

function concatenateUint8Arrays(...arrays) 
{
		let totalLength = 0;
		for (let arr of arrays) {
				totalLength += arr.length;
		}
		let result = new Uint8Array(totalLength);
		let offset = 0;
		for (let arr of arrays) {
				result.set(arr, offset);
				offset += arr.length;
		}
		
		return result;
}

class ColorPaletteModel {
	constructor() {
		this.minValue = 0;
		this.maxValue = 100;
		this.palette = [[0,0,0],[255,255,255]];
	}

	setMinMaxValues(minValue, maxValue) {
		this.minValue = minValue;
		this.maxValue = maxValue;
	}

	getColorForValue(value) {
		let vFrac = 0;
		if (value>this.maxValue) {
			vFrac = 1;
		} else if (value<this.minValue) {
			vFrac = 0;
		}	else {
			vFrac = (value - this.minValue) / (this.maxValue - this.minValue);
		}
		const position = vFrac * (this.palette.length - 1);
		const idx1 = Math.floor(position);
		const idx2 = Math.min(idx1 + 1, this.palette.length - 1);
		if (idx1 == idx2) {
				const color = this.palette[idx1];
				return `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
		}
		const t = position - idx1;
		const color1 = this.palette[idx1];
		const color2 = this.palette[idx2];
		const r = Math.round(color1[0] + (t * (color2[0]-color1[0])));
		const g = Math.round(color1[1] + (t * (color2[1]-color1[1])));
		const b = Math.round(color1[2] + (t * (color2[2]-color1[2])));
		return `rgb(${r}, ${g}, ${b})`;
	}
}

class ViridisPalette extends ColorPaletteModel{
	constructor() {
		super();
		this.palette = [
				[68, 1, 84],
				[71, 16, 90],
				[72, 28, 97],
				[70, 41, 106],
				[65, 53, 115],
				[57, 66, 123],
				[49, 78, 131],
				[42, 91, 140],
				[36, 103, 148],
				[32, 116, 156],
				[30, 128, 164],
				[34, 140, 170],
				[47, 152, 174],
				[68, 164, 175],
				[94, 175, 173],
				[121, 185, 168],
				[149, 194, 160],
				[177, 201, 149],
				[204, 207, 135],
				[229, 211, 120],
				[252, 213, 106],
				[255, 217, 96],
				[255, 221, 92],
				[255, 224, 89],
				[255, 228, 86],
				[255, 231, 86],
				[255, 235, 88],
				[255, 238, 90],
				[255, 242, 92],
				[255, 245, 94],
				[255, 248, 99],
				[255, 251, 104],
				[255, 254, 112],
				[255, 255, 121],
				[255, 255, 130],
				[255, 255, 139],
				[255, 255, 148],
				[255, 255, 157],
				[255, 255, 166],
				[255, 255, 174],
				[255, 255, 183],
				[255, 255, 191],
				[255, 255, 199],
				[255, 255, 207],
				[255, 255, 215],
				[255, 255, 221],
				[255, 255, 228],
				[255, 255, 234],
				[255, 255, 239],
				[255, 255, 244],
				[255, 255, 248],
				[255, 255, 252]
		];
	}
}
</script>
</head>

<body onload="startup()">
	<div class="page-container">
		<div class="title-container">
			<h1>Thermal Image Analysis</h1>
		</div>

		<div class="app-container" id="main_container">

			<div class="thermalanalytics-container">
				<div class="thermalcanvas-container" id="id_thermalCanvasContainer">
					<canvas class="thermalcanvas-element" id="id_thermalCanvas"></canvas>
				</div>
				<div class="measurements-container">
				</div>
			</div>

			<div class="tool-container">
				<h2>Tools</h2>
				<input type="button" id="loadButton" value="Choose File" onclick="document.getElementById('fileInput').click();" />
				<input type="file" style="display:none;" id="fileInput" name="file" onchange="handleFileUpload()"/>
				<br>
				<button onclick="activatePointerTool()">Pointer</button>
				<button onclick="tool2()">Tool 2</button>
				<button onclick="tool3()">Tool 3</button>
			</div>
		</div>
	</div>
</body>
</html>




